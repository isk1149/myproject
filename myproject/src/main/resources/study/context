<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:c="http://www.springframework.org/schema/c"
	xmlns:cache="http://www.springframework.org/schema/cache"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jdbc="http://www.springframework.org/schema/jdbc"
	xmlns:jee="http://www.springframework.org/schema/jee"
	xmlns:lang="http://www.springframework.org/schema/lang"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:task="http://www.springframework.org/schema/task"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
		http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-4.2.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd
		http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.2.xsd
		http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.2.xsd
		http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-4.2.xsd
		http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd
		http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.2.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd">

------------------------------------------------------------------------------------------------------------------------------------

	// 스프링 설정 파일 이름은 무엇이든 상관 없지만 <beans>를 루트 엘리먼트로 사용해야 한다.
	
	

	// <import>엘리먼트는  트랜잭션 관리, 예외 처리, 다국어 처리 등 여러 설정을 할 때 기능별로 xml 파일을 나누는데 이렇게 분리한 설정 파일을 하나로 통합할 때 사용한다.
	<import resource="context-datasource.xml"/>
	<import resource="context-transaction.xml"/>
	
	
	
	// 스프링 설정 파일에 클래스를 등록하려면 <bean> 엘리먼트를 사용한다. 
	<bean id="test" class="com.myproject.webapp.test.Test" init-method="initMethod" destroy-method="destroyMethod" lazy-init="true"
		  scope(설정 안하면 singletonrk default)="singleton or prototype"></bean>
	
	
	
	// 스프링 프레임워크의 가장 중요한 특징은 객체의 생성과 의존관계를 컨테이너가 자동으로 관리한다는 것이다. 이것이 스프링 IoC(제어의 역전)의 핵심이다.
	// 의존성 주입은 컨테이너가 스프링 설정 파일에 등록된 정보를 바탕으로 직접 객체들 사이의 의존관계를 처리하는 것을 의미한다. 생성자 인젝션과 세터 인젝션이 있다. 
	// 생성자 인젝션
	// 스프링 컨테이너는 xml 설정 파일에 등록된 클래스를 찾아서 객체를 생성할 때 기본적으로 매개변수가 없는 기본 생성자를 호출한다.
	// 매개변수를 가지는 생성자를 호출하려면 생성자 인젝션을 사용한다.
	// 아래 예시의 경우 SonySpeaker가 먼저 생성된 후 SamsungTV가 생성된다.
	<bean id="tv" class="polymorphism.SamsungTV">
		<constructor-arg ref="sony"></constructor-arg>
		<constructor-arg value="27000"></constructor-arg>
		
		// 생성자 오버로딩이 되어있다면 헷갈릴 수 있기 때문에 인덱스도 사용 가능하다
		<constructor-arg index="0" ref="sony"></constructor-arg>
		<constructor-arg index="1" value="27000"></constructor-arg>
	</bean>
	<bean id="sony" class="polymorphism.SonySpeaker"></bean>
	
	
	
	// 세터 인젝션
	// 코딩 컨벤션에 따라 보통 세터 인젝션을 사용한다.( 세터 메소드가 제공되지 않는 클래스에 대해서만 생성자 인젝션 사용 )
	// 세터 메소드가 있어야 하고, bean 객체 생성 후에 세터 인젝션이 적용되므로 기본 생성자도 있어야 함
	// name의 첫 글자를 대문자로 바꾸고 앞에 set을 붙인 메소드가 실행된다.
	<bean id="tv" class="polymorphism.SamsungTV">
		<property name="speaker" ref="sony"></property>  -> setSpeaker() 호출
		<property name="price" value="27000"></property>
	</bean>
	<bean id="sony" class="polymorphism.SonySpeaker"></bean>
	
	
	
	// 세터 인젝션을 설정할 때  p네임스페이스를 이용할 수 있다.
	// p네임스페이스는 별도의 schemaLocation이 없기 때문에 네임스페이스만 선언하면 된다.
	<beans xmlns="http://www.springframework.org/schema/beans"
		   ...
		   xmlns:p="http://www.springframework.org/schema/p"
		   ...
		   xsi:schemaLocation="http://www.spring...">
	
	// p네임스페이스를 선언하면 다음과 같이 세터 인젝션이 가능하다
	<bean id="tv" class="polymorphism.SamsungTV" p:speaker-ref="sony" p:price="27000"></bean>
	<bean id="sony" class="polymorphism.SonySpeaker"></bean>
	
	
	
	// 배열, 컬렉션 객체 설정
	// 배열, java.util.List 타입 객체 세터 인젝션( private List<String> addressList; 라고 가정)
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<list>
				<value>서울시 강남구 역삼동</value>
				<value>서울시 성동구 행당동</value>
			</list>
		</property>
	</bean>
	
	// java.util.Set 타입 객체 세터 인젝션( private Set<String> addressList; 라고 가정)
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<set value-type="java.lang.String">
				<value>서울시 강남구 역삼동</value>
				<value>서울시 성동구 행당동</value>
				<value>서울시 성동구 행당동</value> -> Set이라 저장 안 됨
			</set>
		</property>
	</bean>
	
	// java.util.Map 타입 객체 세터 인젝션( private Map<String, Controller> addressList; 라고 가정)
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<map>
				<entry>
					<key><value>고길동</value></key>
					<value>서울시 강남구 역삼동</value>
				</entry>
				<entry>
					<key><value>마이콜</value></key>
					<value>서울시 성동구 성수동</value>
				</entry>
			</map>
		</property>
	</bean>
	
	// java.util.Properties 타입 객체 세터 인젝션( private Properties addressList; 라고 가정)
	// Properties는  key=value 형태의 데이터
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<props>
				<prop key="고길동">서울시 강남구 역삼동</prop>
				<prop key="마이콜">서울시 성동구 성수동</prop>
			</props>
		</property>
	</bean>
	
	
	
	// 어노테이션 설정을 위한 context 네임스페이스 및 스키마 문서 위치 등록, 컴포넌트 스캔 설정
	<beans xmlns="http://www.springframework.org/schema/beans"
		   ...
		   xmlns:context="http://www.springframework.org/schema/context"
		   ...
		   xsi:schemaLocation="http://www.spring...
		   					   http://www.springframework.org/schema/context 
		   					   http://www.springframework.org/schema/context/spring-context-4.2.xsd">
	
	// com.myproject.webapp 패키지 및 그 이하의 패키지 전부 적용 
	<context:component-scan base-package="com.myproject.webapp"></context:component-scan>
	
	// 컴포넌트 스캔 설정을 하면  클래스 위에  @Component 어노테이션을 설정하면 스프링 컨테이너가 객체를 생성해준다. 당연히 기본 생성자가 있어야 한다.
	// id를 설정하려면  @Component("tv")와 같이 설정해주면 되고, 지정하지 않으면 컨테이너가 자동으로 이름을 설정한다.( 이름 규칙은 클래스 이름의 첫 글자를 소문자로 변경한 것이다. )
	
	// 의존성 주입을 지원하는 어노테이션은 [@Autowired, @Qualifier](스프링에서 제공), @Inject, @Resource가 있다.
	
	// @Autowired는 생성자, 메소드, 멤버변수 위에 모두 사용 가능하지만 보통 멤버변수 위에 선언한다.
	// 스프링 컨테이너는 멤버 변수 위에 붙은 @Autowired를 확인한 후 해당 변수의 타입을 체크하여 해당 타입 객체가 메모리에 존재하는지 확인 후 변수에 주입한다.
	// 해당 객체가 메모리에 없다면 NoSuchBeanDefinitionException을 발생시킨다.
	// 문제는 인터페이스 변수 위에 @Autowired가 있고, 메모리에 구현 클래스 객체가 여러 개 있을 때 발생한다.
	// 이런 문제를 해결하기 위해 @Autowired와 @Qualifier("sony")를 같이 설정해준다.
	// 참고로 어노테이션으로 주입하는 경우 세터메소드가 필요 없다.
	@Component("tv")
	public class LgTV implements TV {
		@Autowired
		@Qualifier("sony")
		private Speaker speaker;
		
		public LgTV() { }
	}
	
	// @Resource는 객체의 이름을 이용하여 의존성 주입을 처리한다. @Inject도 이름 기반의 의존성 주입을 한다.
	@Component("tv")
	public class LgTV implements TV {
		@Resource(name="sony")
		private Speaker speaker;
		
		public LgTV() { }
	}
	
	
	
	// <bean> 엘리먼트 등록과 어노테이션을 적절히 사용해주면 좋다.
	// 변경되지 않는 객체는 어노테이션으로 설정하고, 변경될 가능성이 있는 객체는  <bean> 엘리먼트로 설정한다.
	// 참고로 라이브러리 형태로 제공되는 클래스는 xml 설정만 가능한다.
	
	
	
	// Presentation_And_Business_Layer.png 파일 확인
	// 프레젠테이션 레이어는 사용자와의 커뮤니케이션을 담당하고, 비즈니스 레이어는 사용자의 요청에 대한 비즈니스 로직 처리를 담당한다.
	// 이 구조에서 핵심은 Controller, ServiceImpl, DAO 클래스이다.
	// Controller : 사용자 요청 제어,  ServiceImpl: 비즈니스 로직 처리,   DAO : DB연동
	// 스프링 프레임워크에서는 이런 클래스들을 구분하기 위해  @Component를 상속한 3개의 어노테이션을 추가로 제공하고 각각 특별한 기능을 가지고 있다.
	-------------------------------------------------------------------------
	|	어노테이션		|		위치			|				의미					|
	-------------------------------------------------------------------------
	| @Service		| XXXServiceImpl	| 비즈니스 로직을 처리하는 Service 클래스		|
	-------------------------------------------------------------------------
	| @Repository	| XXXDAO			| DB연동을 처리하는 DAO 클래스				|
	-------------------------------------------------------------------------
	| @Controller	| XXXController		| 사용자 요청을 제어하는 Controller 클래스		|
	-------------------------------------------------------------------------
	
	
	
	// VO 클래스는 레이어와 레이어 사이에서 관련된 데이터를 한 번에 주고받을 목적으로 사용한다.
	// 하나의 테이블마다 하나의 VO 클래스가 있고, 테이블이름 뒤에 VO 붙인다.
	// 필드도 컬럼 이름과 타입에 맞게 private로 설정하고 게터/세터 메소드를 만들어주면 된다.
	
	
	
	// DAO 클래스는 DB 연동을 담당한다. CRUD 기능의 메소드를 구현하면 된다. @Repository("XXXDAO") 어노테이션을 지정해준다.
	// CRUD 기능 메소드 이름은 기능+테이블명으로 지정한다.( insert, update, delete, get, getXXXList 등 )
	
	
	
	// DB 연동을 위해 JDBC 드라이버가 필요하다. pom.xml에 작성한다.
	// oracle, mysql 관련 설정은 따로 찾아보기
	<!-- h2 database -->
	<dependency>
		<groupId>com.h2database</groupId>
		<artifactId>h2</artifactId>
		<version>2.1.212</version>
	</dependency>
	
	
	 
	// 서비스 인터페이스는 DAO 클래스에서  Alt+Shift+T를 눌러 쉽게 생성할 수 있다.(이클립스 기준)
	// 서비스 인터페이스를 구현한 서비스 XXXServiceImpl 클래스를 구현해준다.
	// @Service("XXXService") 어노테이션을 지정해주고, 필드의  private XXXDAO xxxDAO; 를 @Autowired 어노테이션으로 지정해준다.

------------------------------------------------------------------------------------------------------------------------------------
	
	// 비즈니스 컴포넌트 개발에서 중요한 두 가지는 낮은 결합도와 높은 응집도를 유지하는 것이다.
	// 스프링의 의존성 주입을 이용하면 비즈니스 컴포넌트를 구성하는 객체들의 결합도를 낮출 수 있다.
	// AOP는 응집도를 높일 수 있다.
	
	// AOP를 이해하는 데 가장 핵심 개념은 관심 분리이다.
	// AOP에서는 메소드마다 공통으로 등장하는 로깅이나 예외, 트랜잭션 처리 같은 코드들을 횡단 관심이라고 한다.
	// 이에 반해 사용자의 요청에 따라 실제로 수행되는 핵심 비즈니스 로직을 핵심 관심이라고 한다.
	
	
	
	// AOP를 적용하기 위해서 우선 pom.xml을 수정하여 AOP관련 라이브러리를 추가한다.
	<dependency>
		<groupId>org.aspectj</groupId>
		<artifactId>aspectjweaver</artifactId>
		<version>1.8.8</version>
	</dependency>
	
	// 스프링 설정 파일(applicationContext.xml)에서 aop 네임스페이스를 추가한다.
	<beans xmlns="http://www.springframework.org/schema/beans"
		   ...
		   xmlns:aop="http://www.springframework.org/schema/aop"
		   ...
		   xsi:schemaLocation="http://www.spring...
		   					   http://www.springframework.org/schema/aop 
		   					   http://www.springframework.org/schema/aop/spring-aop-4.2.xsd">
	
	// 이제 aop 관련 설정을 작성한다.
	// 아래 설정은 allPointcut으로 설정한 포인트컷 메소드가 호출되면 log라는 어드바이스 객체의 printLog 메소드가 실행되고 이때 printLog의 동작 시점은 before라는 뜻이다.
	<bean id="log" class="com.springbook.biz.comm.LogAdvice"></bean>
	<aop:config>
		<aop:pointcut id="allPointcut" expression="execution( * com.springbook.biz..*Impl.*(..) )"/>
		<aop:aspect ref="log">
			<aop:before pointcut-ref="allPointcut" method="printLog"/>
		</aop:aspect>
	</aop:config>
	
	
	
	// 조인포인트 : 클라이언트가 호출하는 모든 비즈니스 메소드. XXXServiceImpl 클래스의 모든 메소드가 조인포인트라고 생각하면 된다.
	// 포인트컷 : 횡단 관심을 적용시킬 필터링된 조인포인트이다. 핵심 관심이라고 보면 된다.
	// 어드바이스 : 횡단 관심에 해당하는 공통 기능의 코드이다. 어드바이스 동작 시점은  before, after-returning, after-throwing, after, around가 있다.
	// 위빙 : 포인트컷으로 지정한 핵심 관심 메소드가 호출될 때, 어드바이스에 해당하는 횡단 관심 메소드가 삽입되는 과정을 의미한다.
	
	// AOP(Aspect Oriented Programming)이라는 이름에서 알 수 있듯이 AOP의 핵심은 애스팩트이다.
	// 애스팩트는 포인트컷과 어드바이스의 결합이다. 어떤 포인트컷 메소드에 대해 어떤 어드바이스 메소드를 실행할지 결정한다. 
	
	
	
	// AOP 설정에서 <aop:config>는 루트 엘리먼트이다. 스프링 설정 파일 내에 여러번 사용할 수 있고, 하위에는 <aop:pointcut>, <aop:aspect>가 위치할 수 있다. 
	// <aop:pointcut> 엘리먼트는 포인트컷을 지정할 때 사용한다. 만약 <aop:aspect> 하위에 설정되면 해당 <aop:aspect>에서만 사용 가능하다.
	// 애스팩트는 <aop:aspect> 엘리먼트로 설정하며, 핵심 관심에 해당하는 포인트컷 메소드와 횡단 관심에 해당하는 어드바이스 메소드를 결합하기 위해 사용한다. 
	// 만약 어드바이스 객체의 아이디를 모르거나 메소드 이름을 확인할 수 없을 경우 애스팩트를 설정할 수 없다. 이런 경우 <aop:advisor> 엘리먼트를 사용한다.
	
	
	
	// 포인트컷 표현식
	// execution( * com.springbook.biz..*Impl.*(..) )
	
	// 리턴타입 지정
	-------------------------------------------------------------------------
	|	표현식	|				설명											|
	-------------------------------------------------------------------------
	| *			| 모든 리턴타입 허용												|
	-------------------------------------------------------------------------
	| void		| 리턴타입이 void인 메소드 선택										|
	-------------------------------------------------------------------------
	| !void		| 리턴 타입이 void가 아닌 메소드 선택									|
	-------------------------------------------------------------------------	
	
	// 패키지 지정
	-------------------------------------------------------------------------------------------------
	|	표현식						|				설명												|
	-------------------------------------------------------------------------------------------------
	| com.springbook.biz			| 정확하게 com.springbook.biz 패키지만 선택								|
	-------------------------------------------------------------------------------------------------
	| com.springbook.biz..			| com.springbook.biz 패키지로 시작하는 모든 패키지 선택						|
	-------------------------------------------------------------------------------------------------
	| com.springbook..impl			| com.springbook 패키지로 시작하면서 마지막 패키지 이름이 impl로 끝나는 패키지 선택	|
	-------------------------------------------------------------------------------------------------
	
	// 클래스 지정
	-----------------------------------------------------------------------------
	|	표현식			|				설명										|
	-----------------------------------------------------------------------------
	| BoardServiceImpl	| 정확하게 BoardServiceImpl 클래스만 선택						|
	-----------------------------------------------------------------------------
	| *Impl				| 클래스 이름이 Impl로 끝나는 클래스만 선택							|
	-----------------------------------------------------------------------------
	| BoardService+		| 클래스 이름 뒤에 '+'가 붙으면 해당 클래스로부터 파생된 모든 자식 클래스 선택. 	|
	|					| 인터페이스 뒤에 '+'가 붙으면 해당 인터페이스를 구현한 모든 클래스 선택			|
	-----------------------------------------------------------------------------
	
	// 메소드 지정
	-------------------------------------------------------------------------
	|	표현식	|				설명											|
	-------------------------------------------------------------------------
	| *(..)		| 가장 기본 설정으로 모든 메소드 선택									|
	-------------------------------------------------------------------------
	| get*(..)	| 메소드 이름이 get으로 시작하는 모든 메소드 선택							|
	-------------------------------------------------------------------------

	// 매개변수 지정
	-------------------------------------------------------------------------------------------------
	|	표현식						|				설명												|
	-------------------------------------------------------------------------------------------------
	| (..)							| 가장 기본 설정으로 '..'은 매개변수의 개수와 타입에 제약이 없음을 의미					|
	-------------------------------------------------------------------------------------------------
	| (*)							| 반드시 1개의 매개변수를 가지는 메소드만 선택									|
	-------------------------------------------------------------------------------------------------
	| (com.springbook.user.UserVO)	| 매개변수로 UserVO를 가지는 메소드만 선택. 패키지 경로가 포함되어야 함				|
	-------------------------------------------------------------------------------------------------
	| (!com.springbook.user.UserVO)	| 매개변수로 UserVO를 가지지 않는 메소드만 선택								|
	-------------------------------------------------------------------------------------------------
	| (Integer, ..)					| 한 개 이상의 매개변수를 가지되, 첫 번째 매개변수의 타입이 Integer인 메소드만 선택		|
	-------------------------------------------------------------------------------------------------
	| (Integer, *)					| 반드시 두 개의 매개변수를 가지되, 첫 번째 매개변수의 타입이 Integer인 메소드만 선택		|
	-------------------------------------------------------------------------------------------------
	
	
	
	// 어드바이스 동작 시점
	-------------------------------------------------------------------------------------------------
	|	동작 시점			|				설명															|
	-------------------------------------------------------------------------------------------------
	| Before			| 비즈니스 메소드 실행 전 동작															|
	-------------------------------------------------------------------------------------------------
	| After Returning	| 비즈니스 메소드가 성공적으로 리턴되면 동작												|
	-------------------------------------------------------------------------------------------------
	| After Throwing	| 비즈니스 메소드 실행 중 예외가 발생하면 동작(try ~ catch 블록에서 catch 블록에 해당)				|
	-------------------------------------------------------------------------------------------------
	| After				| 비즈니스 메소드 실행된 후, 무조건 실행(try ~ catch ~ finally 블록에서 finally 블록에 해당)	|
	-------------------------------------------------------------------------------------------------
	| Around			| 메소드 호출 자체를 가로채 비즈니스 메소드 실행 전후에 처리할 로직을 삽입할 수 있음						|
	-------------------------------------------------------------------------------------------------
	// 참고로 예외가 발생한 상황에서도 <aop:after>가 먼저 적용된다.
	// Around 어드바이스는 클라이언트의 메소드 호출을 가로챈 후 해당 비즈니스 메소드가 실행되기 전에 사전 처리 로직을 수행할 수 있고 비즈니스 메소드 실행 후에 사후 처리 로직을 수행할 수 있다.
	// 사전 처리 로직은 Before 어드바이스와 동일하게 동작하고, 사후 처리 로직은 After 어드바이스와 동일하게 동작한다.
	public class AroundAdvice {
		public Object aroundLog(ProceedingJoinPoint pjp) throws Throwable {
			// 사전 처리 로직
			Object obj = pjp.proceed();
			// 사후 처리 로직
			return obj;
		}
	}
	
	
	
	// 횡단 관심에 해당하는 어드바이스 메소드를 의미 있게 구현하려면 클라이언트가 호출한 비즈니스 메소드의 정보가 필요하다.
	// 스프링에서는 비즈니스 메소드의 다양한 정보를 이용할 수 있도록 JoinPoint 인터페이스를 제공한다.
	// 주의할 점은 Around 어드바이스에서는 ProceedingJoinPoint를 사용해야 한다.(JoinPoint를 상속하고 proceed()를 추가했다)
	// JoinPoint에서 제공하는 메소드
	-----------------------------------------------------------------------------------------------------
	|	메소드					|				설명														|
	-----------------------------------------------------------------------------------------------------
	| Signature getSignature()	| 클라이언트가 호출한 메소드의 시그니처(리턴타입, 이름, 매개변수) 정보가 저장된 Signature 객체 리턴	|
	-----------------------------------------------------------------------------------------------------
	| Object getTarget()		| 클라이언트가 호출한 비즈니스 메소드를 포함하는 비즈니스 객체 리턴								|
	-----------------------------------------------------------------------------------------------------
	| Object[] getArgs()		| 클라이언트가 메소드를 호출할 때 넘겨준 인자 목록을 Object 배열로 리턴						|
	-----------------------------------------------------------------------------------------------------
	
	
	
	// getSignature() 메소드가 리턴하는 Signature 객체를 이용하면, 호출되는 메소드에 대한 다양한 정보를 얻을 수 있다.
	// Signature가 제공하는 메소드
	-----------------------------------------------------------------------------------------------------
	|	메소드					|				설명														|
	-----------------------------------------------------------------------------------------------------
	| String getName()			| 클라이언트가 호출한 메소드 이름 리턴												|
	-----------------------------------------------------------------------------------------------------
	| String toLongString()		| 클라이언트가 호출한 메소드의 리턴타입, 이름, 매개변수를 패키지 경로까지 포함하여 리턴				|
	-----------------------------------------------------------------------------------------------------
	| String toShortString()	| 클라이언트가 호출한 메소드 시그니처를 축약한 문자열로 리턴									|
	-----------------------------------------------------------------------------------------------------
	
	
	
	// JoinPoint 객체를 사용하려면 JoinPoint를 어드바이스 메소드 매개변수로 선언하면 된다.
	// 그러면 클라이언트가 비즈니스 메소드를 호출할 때, 스프링 컨테이너가 JoinPoint 객체를 생성한다.
	// 그리고 메소드 호출과 관련된 모든 정보를 JoinPoint 객체에 저장하여 어드바이스 메소드를 호출할 때 인자로 넘겨준다.
	ex)
	public void beforeLog(JoinPoint jp) {
		String method = jp.getSignature().getName();
		Object[] args = jp.getArgs();
		System.out.println("메소드 : " + method + "(), 메소드 인자 : " + args[0].toString());
	}
	
	
	// After Returning 어드바이스 메소드에 바인드 변수가 추가됐다면 바인드 변수에 대한 매핑 설정을 스프링 설정 파일에 추가해야 한다.
	// <aop:after-returning pointcut-ref="allPointcut" method="afterLog" returning="returnObj"/>
	public void afterLog(JoinPoint jp, Object returnObj) { // Object returnObj -> 바인드 변수
		String method = jp.getSignature().getName();
		if (returnObj instanceof UserVO) {
			...
		}
		System.out.println("메소드 : " + method + "(), 메소드 리턴값 : " + returnObj.toString());
	}
	
	
	// After Throwing 어드바이스 메소드에 바인드 변수가 추가됐다면 바인드 변수에 대한 매핑 설정을 스프링 설정 파일에 추가해야 한다.
	// <aop:after-throwing pointcut-ref="allPointcut" method="exceptionLog" throwing="exceptionObj"/>
	public void exceptionLog(JoinPoint jp, Exception exceptionObj) { // Exception exceptionObj -> 바인드 변수
		String method = jp.getSignature().getName();
		System.out.println("메소드 : " + method + "(), 메소드 수행 중 발생한 예외 메시지 : " + exceptionObj.getMessage());
	}
	
	
	
	// AOP도 IoC와 마찬가지로 어노테이션 설정을 지원한다.
	// 스프링 설정 파일에 <aop:aspectj-autoproxy> 엘리먼트만 선언하면 스프링 컨테이너는 AOP 관련 어노테이션들을 인식하고 용도에 맞게 처리해준다.
	
	// AOP 관련 어노테이션은 어드바이스 클래스에 설정한다.
	// 어노테이션 설정으로 포인트컷을 선언할 때는  @Pointcut을 사용하며 포인트컷을 식별하기 위한 참조 메소드를 이용한다.
	@Pointcut("execution( * com.springbook.biz..*Impl.*(..) )")
	public void allPointcut() {}
	
	// 어드바이스 클래스에는 횡단 관심에 해당하는 어드바이스 메소드가 있다.
	// 이 어드바이스 메소드가 언제 동작할지 결정하여 관련된 어노테이션을 메소드 위에 설정하면 된다.
	@Before("allPointcut()")
	public void printLog() {...}
	
	// 다음은 어드바이스 동작 시점과 관련된 어노테이션이다.
	// @Before,  @AfterReturning,  @AfterThrowing,  @After,  @Around
	
	// 애스팩트는 @Aspect를 이용하여 설정한다.
	// 애스팩트는 포인트컷과 어드바이스의 결합이다. 따라서 @Aspect가 설정된 애스팩트 객체에는 반드시 포인트컷과 어드바이스를 결합하는 설정이 있어야 한다.
	
	// 어드바이스 클래스마다 포인트컷 설정을 하지 않으려면 포인트컷을 외부에 독립된 클래스에 따로 설정하면 된다.
	@Aspect
	public class PointcutCommon {
		@Pointcut("execution( * com.springbook.biz..*Impl.*(..) )")
		public void allPointcut() {}
		
		@Pointcut("execution( * com.springbook.biz..*Impl.get*(..) )")
		public void getPointcut() {}
	}
	
	// 아래는 어드바이스 클래스 예시이다.
	@Service
	@Aspect
	public class BeforeAdvice {
		@Before("PointcutCommon.allPointcut()")
		public void beforeLog(JoinPoint jp) {
			String method = jp.getSignature().getName();
			Object[] args = jp.getArgs();
			System.out.println("메소드 : " + method + "(), 메소드 인자 : " + args[0].toString());
		}
	}
	
	
	@Service
	@Aspect
	public class AfterReturningAdvice {
		@AfterReturning(pointcut="PointcutCommon.allPointcut()", returning="returnObj")
		public void afterLog(JoinPoint jp, Object returnObj) { // Object returnObj -> 바인드 변수
			String method = jp.getSignature().getName();
			if (returnObj instanceof UserVO) {
				...
			}
			System.out.println("메소드 : " + method + "(), 메소드 리턴값 : " + returnObj.toString());
		}
	}
	
	
	@Service
	@Aspect
	public class AfterThrowingAdvice {
		@AfterThrowing(pointcut="PointcutCommon.allPointcut()", throwing="exceptionObj")
		public void exceptionLog(JoinPoint jp, Exception exceptionObj) { // Exception exceptionObj -> 바인드 변수
			String method = jp.getSignature().getName();
			System.out.println("메소드 : " + method + "(), 메소드 수행 중 발생한 예외 메시지 : " + exceptionObj.getMessage());
		}
	}
	
	
	@Service
	@Aspect
	public class AfterAdvice {
		@After("PointcutCommon.allPointcut()")
		public void finallyLog(JoinPoint jp) { 
			String method = jp.getSignature().getName();
			System.out.println("메소드 : " + method + "()");
		}
	}
	
	
	@Service
	@Aspect
	public class AroundAdvice {
		@Around("PointcutCommon.allPointcut()")
		public Object aroundLog(ProceedingJoinPoint pjp) throws Throwable {
			// 사전 처리 로직
			Object obj = pjp.proceed();
			// 사후 처리 로직
			return obj;
		}
	}
	
	
	
	// JDBC를 이용하여 DB 연동 프로그램을 개발하면 비슷한 코드를 SQL만 바꿔 사용하는 경우가 대부분이다.
	// 스프링은 JDBC 기반의 DB 연동 프로그램을 쉽게 개발할 수 있도록 JdbcTemplage 클래스를 지원한다.
	
	// JdbcTemplate은  GoF 디자인 패턴 중 템플릿 메소드 패턴이 적용된 클래스이다.
	// 템플릿 메소드 패턴은 복잡하고 반복되는 알고리즘을 캡슐화해서 재사용하는 패턴으로 정의할 수 있다. 즉, JDBC처럼 코딩 순서가 정형화된 기술에서 유용하다.
	// 반복되는 DB 연동 로직은 JdbcTemplate 클래스의 템플릿 메소드가 제공하고, 개발자는 달라지는 SQL 구문과 설정값만 신경 쓰면 된다.
	
	// 스프링 JDBC를 이용하려면 pox.xml 파일에 DBCP 관련 <dependency>를 추가한다.
	<!-- Spring -->
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-jdbc</artifactId>
		<version>${org.springframework-version}</version>
	</dependency>
	
	<!-- DBCP -->
	<dependency>
		<groupId>commons-dbcp</groupId>
		<artifactId>commons-dbcp</artifactId>
		<version>1.4</version>
	</dependency>
	
	
	
	// JdbcTemplate가 JDBC API를 이용하여  DB 연동을 처리하려면 반드시  DB로부터 커넥션을 얻어야 한다.
	// 따라서 JdbcTemplate 객체가 사용할 DataSource를 <bean> 등록하여 스프링 컨테이너가 생성하도록 해야 한다.
	<!-- DataSource 설정 -->
	<bean id="dataSource" class="org.apache.common.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="org.h2.Driver"/>
		<property name="url" value="jdbc:h2:tcp://localhost/~/test"/>
		<property name="username" value="sa"/>
		<property name="password" value=""/>
	</bean>
	
	
	
	// PropertyPlaceholderConfigurer를 이용하면 외부의 프로퍼티 파일을 참조하여 DataSource를 설정할 수 있다.
	// src/main/resources 소스 폴더에 config 폴더를 생성하고 폴더 안에 database.properties 파일을 작성하였다.
	jdbc.driver=org.h2.Driver
	jdbc.url=jdbc:h2:tcp://localhost/~/test
	jdbc.username=sa
	jdbc.password=
	
	// 이제 Properties 파일에 설정된 프로퍼티들을 이용하여 DataSource를 설정하려면 다음과 같이 설정한다.
	<!-- DataSource 설정 -->
	<context:property-placeholder location="classpath:config/database.properties"/>
	
	<bean id="dataSource" class="org.apache.common.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="${jdbc.driver}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>	
	
	
	
	// 스프링 JDBC 설정이 되었으니 이제 JdbcTemplate 객체를 이용하여 DB 연동을 처리할 수 있다.
	// 쿼리의 ? 부분에 값을 차례로 나열하거나 값이 세팅되어 있는 배열 객체를 전달하는 방식이 있다.
	
	// insert, update, delete 구문을 처리할 때는 JdbcTemplate 클래스의 update() 메소드를 사용한다.
	-----------------------------------------------------------------------------------------------------------------
	|	메소드	|	int update(String sql, Object...args)															|
	-----------------------------------------------------------------------------------------------------------------
	| 	사용 예	| 	// 글 수정																							|
	|			|	public void updateBoard(BoardVO vo) {															|
	|			|		String BOARD_UPDATE = update board set title=?, content=? where seq=?";						|
	|			|		int cnt = jdbcTemplate.upate(BOARD_UPDATE, vo.getTitle(), vo.getContent(), vo.getSeq());	|
	|			|		System.out.println(cnt + "건 데이터 수정");														|
	|			|	}																								|
	-----------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------
	|	메소드	|	int update(String sql, Object[] args)															|
	-----------------------------------------------------------------------------------------------------------------
	| 	사용 예	| 	// 글 수정																							|
	|			|	public void updateBoard(BoardVO vo) {															|
	|			|		String BOARD_UPDATE = update board set title=?, content=? where seq=?";						|
	|			|		Object[] args = {vo.getTitle(), vo.getContent(), vo.getSeq()};								|
	|			|		int cnt = jdbcTemplate.upate(BOARD_UPDATE, args);											|
	|			|		System.out.println(cnt + "건 데이터 수정");														|
	|			|	}																								|
	-----------------------------------------------------------------------------------------------------------------	
	
	
	// select 구문으로 검색된 정수값을 리턴받으려면 queryForInt() 메소드를 사용한다.
	-----------------------------------------------------------------------------------------------------------------
	|	메소드	|	int queryForInt(String sql)																		|
	|			|	int queryForInt(String sql, Object...args)														|
	|			|	int queryForInt(String sql, Object[] args)														|
	-----------------------------------------------------------------------------------------------------------------
	| 	사용 예	| 	// 전체 게시글 수 조회																					|
	|			|	public void getBoardTotalCount(BoardVO vo) {													|
	|			|		String BOARD_TOT_COUNT = "select count(*) from board";										|
	|			|		int cnt = jdbcTemplate.queryForInt(BOARD_TOT_COUNT);										|
	|			|		System.out.println("전체 게시글 수 : " + cnt + "건");												|
	|			|	}																								|
	-----------------------------------------------------------------------------------------------------------------
	
	
	// select 구문의 실행 결과를 특정 자바 객체로 매핑하여 리턴받을 때는 queryForObject()를 사용한다.
	// queryForObject()는 검색 결과가 없거나 검색 결과가 두 개 이상이면 예외( IncorrectResultSizeDataAccessException )를 발생시킨다.
	// 그리고 검색 결과를 자바 객체로 매핑할 RowMapper 객체를 반드시 지정해야 한다.
	-----------------------------------------------------------------------------------------------------------------
	|	메소드	|	Object queryForObject(String sql)																|
	|			|	Object queryForObject(String sql, RowMapper<T> rowMapper)										|
	|			|	Object queryForObject(String sql, Object[] args, RowMapper<T> rowMapper)						|
	-----------------------------------------------------------------------------------------------------------------
	| 	사용 예	| 	// 글 상세 조회																						|
	|			|	public BoardVO getBoardTotalCount(BoardVO vo) {													|
	|			|		String BOARD_GET = "select * from board where seq=?";										|
	|			|		Object[] args = {vo.getSeq()};																|
	|			|		return jdbcTemplate.queryForObject(BOARD_GET, args, new BoardRowMapper());					|
	|			|	}																								|
	-----------------------------------------------------------------------------------------------------------------
	
	// 검색 결과를 특정 VO 객체에 매핑하여 리턴하려면  RowMapper 인터페이스를 구현한 클래스가 필요하다. 결국 RowMapper 클래스는 테이블당 하나씩은 필요하다는 뜻이다.
	// RowMapper 객체를 queryForObject() 메소드의 매개변수로 넘겨주면, 스프링 컨테이너는 SQL 구문을 수행한 후 자동으로 RowMapper 객체의 mapRow() 메소드를 호출한다. 
	// RowMapper 인터페이스에는 mapRow() 메소드가 있어서 검색 결과로 얻어낸 row 정보를 어떤 VO에 어떻게 매핑할 것인지를 구현해주면 된다.
	public class BoardRowMapper implements RowMapper<BoardVO> {
		public BoardVO mapRow(ResultSet rs, int rowNum) throws SQLException {
			BoardVO board = new BoardVO();
			board.setSeq(rs.getInt("seq"));	
			board.setSeq(rs.getInt("title"));	
			...
			return board;
		}
	}
	
	
	// select 구문의 결과가 목록일 때는 query() 메소드를 사용한다.
	// 검색된 데이터 row 수만큼 RowMapper 객체의 mapRow() 메소드가 실행된다. 이렇게 row 정보가 매핑된 VO객체 여러 개가 List 컬렉션에 저장되어 리턴된다.
	-----------------------------------------------------------------------------------------------------------------
	|	메소드	|	List query(String sql)																			|
	|			|	List query(String sql, RowMapper<T> rowMapper)													|
	|			|	List query(String sql, Object[] args, RowMapper<T> rowMapper)									|
	-----------------------------------------------------------------------------------------------------------------
	| 	사용 예	| 	// 글 목록 조회																						|
	|			|	public List<BoardVO> getBoardList(BoardVO vo) {													|
	|			|		String BOARD_LIST = "select * from board order by seq desc";								|
	|			|		return jdbcTemplate.query(BOARD_LIST, new BoardRowMapper());								|
	|			|	}																								|
	-----------------------------------------------------------------------------------------------------------------
	

	
	// JdbcTemplate 객체를 이용하여 DAO 클래스를 구현하려면 두 가지 방법이 있다.
	// 1. JdbcDaoSupport 클래스 상속
	// JdbcDaoSupport 클래스를 상속받으면 getJdbcTemplate() 메소드를 상속받을 수 있다.
	// 단, DataSource 객체를 의존성 주입해야 한다.
	// @Autowired 어노테이션은 주로 변수 위에 선언하기는 하지만, 메소드 위에 선언해도 스프링 컨테이너가 매개변수 타입을 확인하고 해당 타입 객체를 메모리에서 확인하여 인자로 넘겨준다.
	@Repository
	public class BoardDaoSpring extends JdbcDaoSupport {
		private final String BOARD_INSERT = "insert into...";
		...
		
		@Autowired
		public void setSuperDataSource(DataSource dataSource) {
			super.setDataSource(dataSource);
		}
	
		public void insetBoard(BoardVO vo) {
			getJdbcTemplate().update(BOARD_INSERT, vo.getTitle(), vo.getWriter(), vo.getContect());
		}
		...
	}
	
	
	// 2. JdbcTemplate 클래스 <bean> 등록, 의존성 주입( 일반적으로 이 방법을 사용한다 )
	<!-- DataSource 설정 -->
	<bean id="dataSource" class="org.apache.common.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="org.h2.Driver"/>
		<property name="url" value="jdbc:h2:tcp://localhost/~/test"/>
		<property name="username" value="sa"/>
		<property name="password" value=""/>
	</bean>
	
	<!-- Spring JDBC 설정 -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource"/>
	</bean>
	
	@Repository
	public class BoardDaoSpring {
		@Autowired
		private JdbcTemplate jdbcTemplate;
	
		private final String BOARD_INSERT = "insert into...";
		...
	
		public void insetBoard(BoardVO vo) {
			jdbcTemplate.update(BOARD_INSERT, vo.getTitle(), vo.getWriter(), vo.getContect());
		}
		...
	}
	
	
	
	// 스프링에서 트랜잭션 처리를 컨테이너가 자동으로 처리하도록 설정할 수 있는데, 이를 선언적 트랜잭션 처리라 한다.
	// 스프링 트랜잭션 설정에서는 <aop:advisor> 엘리먼트를 사용한다.
	// 스프링 설정 파일에 트랜잭션 관련 네임스페이스를 추가해야 한다.
	<beans xmlns="http://www.springframework.org/schema/beans"
		   ...
		   xmlns:aop="http://www.springframework.org/schema/aop"
		   xmlns:aop="http://www.springframework.org/schema/tx"
		   ...
		   xsi:schemaLocation="http://www.spring...
		   					   http://www.springframework.org/schema/aop 
		   					   http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
		   					   http://www.springframework.org/schema/tx
		   					   http://www.springframework.org/schema/tx/spring-tx-4.2.xsd">	
	
	// 트랜잭션 관련 설정에서 가장 먼저 등록하는 것은 트랜잭션 관리자 클래스이다.
	// 모든 트랜잭션 관리자는 PlatformTransactionManager 인터페이스를 구현한 클래스이다.
	public interface PlatformTransactionManager {
		TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
		void commit(TransactionStatus status) throws TransactionException;
		void rollback(TransactionStatus status) throws TransactionException;
	}
	
	// 당분간은 DataSourceTransactionManager 클래스를 이용하여 트랜잭션을 처리할 것이다.
	// 이후에 JPA를 이용하여 DAO 클래스를 구현한다면 JPATransactionManager를 등록하면 된다.
	<!-- DataSource 설정 -->
	<bean id="dataSource" class="org.apache.common.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="org.h2.Driver"/>
		<property name="url" value="jdbc:h2:tcp://localhost/~/test"/>
		<property name="username" value="sa"/>
		<property name="password" value=""/>
	</bean>
	
	<!-- Transaction 설정 -->
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>
	
	// 우리는 비즈니스 메소드가 실행하다가 예외가 발생하면 해당 메소드에 대한 트랜잭션을 rollback하고, 정상 종료되면 해당 메소드에 대한 트랜잭션을 commit하면 된다.
	// 트랜잭션을 commit, rollback 하기 위한 객체가 DataSourceTransactionManager이므로 이제 이 트랜잭션 관리자를 이용하여 트랜잭션을 제어하는 어드바이스를 등록한다.
	
	// 트랜잭션 관리 기능의 어드바이스는 스프링 설정 파일에 <tx:advice> 엘리먼트를 사용하여 설정한다.
	<!-- Transaction 설정 -->
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>
	
	<!-- Transaction 어드바이스 설정 -->
	<tx:advice id="txAdvice" transaction-manager="txManager">
		<tx:attributes>
			<tx:method name="get* read-only="true"/>
			<tx:method name="*"/>
		</tx:attributes>
	</tx:advice>
	
	// 이전에는 AOP 관련 설정에 사용한 어드바이스는 직접 구현했었다.
	// 하지만 트랜잭션 관리 기능의 어드바이스는 스프링 컨테이너가 <tx:advice> 설정을 참조하여 자동으로 생성한다.
	// 이 말은 트랜잭션 관리 어드바이스 객체의 클래스 이름이나 메소드를 확인할 수 없다는 뜻이기도 하다.
	// 우리가 할 수 있는 것은 단지 생성되는 어드바이스 아이디를 id속성으로, 어드바이스 객체가 사용할 트랜잭션 관리자를 transaction-manager 속성으로 지정할 뿐이다.
	
	// <tx:attributes>의 자식 엘리먼트로 <tx:method> 엘리먼트를 이용하여 트랜잭션을 적용할 메소드를 지정할 수 있다.
	// 위 설정은 get으로 시작하는 모든 메소드는 읽기 전용으로 처리되어 트랜잭션 관리 대상에서 제외하고 나머지 메소드들은 트랜잭션 관리에 포함한 것이다.
	// 다음은 <tx:method> 엘리먼트가 가질 수 있는 속성 값이다.
	-----------------------------------------------------------------------------------------------------
	|	속성				|				의미																|
	-----------------------------------------------------------------------------------------------------
	| name				| 트랜잭션이 적용될 메소드 이름															|
	-----------------------------------------------------------------------------------------------------
	| read-only			| 읽기 전용 여부 지정(기본값 false)														|
	-----------------------------------------------------------------------------------------------------
	| no-rollback-for	| 트랜잭션을 롤백하지 않을 예외 지정															|
	-----------------------------------------------------------------------------------------------------
	| rollback-for		| 트랜잭션을 롤백할 예외 지정																|
	-----------------------------------------------------------------------------------------------------	
	
	
	
	// 트랜잭션 관리 어드바이스까지 설정했으면 비즈니스 메소드 실행 후에 트랜잭션 관리 어드바이스가 동작하도록 AOP 설정을 하면 된다.
	// 트랜잭션 관리 어드바이스는 우리가 직접 클래스를 구현하지 않고, <tx:advice> 설정을 통해 스프링 컨테이너가 자동으로 생성하므로 어드바이스 메소드 이름을 알 수 없다.
	// 따라서 <aop:advisor> 엘리먼트를 사용한다.
	<tx:advice id="txAdvice" transaction-manager="txManager">
		<tx:attributes>
			<tx:method name="get* read-only="true"/>
			<tx:method name="*"/>
		</tx:attributes>
	</tx:advice>
	
	<aop:config>
		<aop:pointcut id="txPointcut" expression="execution( * com.springbook.biz..*(..) )"/>
		<aop:advisor pointcut-ref="txPointcut" advice-ref="txAdvice"/>
	</aop:config>
	
	
	
	// 결과적으로 트랜잭션 설정 관련 엘리먼트는 다음과 같다.
	<!-- DataSource 설정 -->
	<bean id="dataSource" class="org.apache.common.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="org.h2.Driver"/>
		<property name="url" value="jdbc:h2:tcp://localhost/~/test"/>
		<property name="username" value="sa"/>
		<property name="password" value=""/>
	</bean>
	
	<!-- Spring JDBC 설정 -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource"/>
	</bean>
	
	<!-- Transaction 설정 -->
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>
	
	<!-- Transaction 어드바이스 설정 -->
	<tx:advice id="txAdvice" transaction-manager="txManager">
		<tx:attributes>
			<tx:method name="get* read-only="true"/>
			<tx:method name="*"/>
		</tx:attributes>
	</tx:advice>
	
	<!-- AOP 설정 -->
	<aop:config>
		<aop:pointcut id="txPointcut" expression="execution( * com.springbook.biz..*(..) )"/>
		<aop:advisor pointcut-ref="txPointcut" advice-ref="txAdvice"/>
	</aop:config>
	
------------------------------------------------------------------------------------------------------------------------------------

	
	
	
	
	

</beans>