<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:c="http://www.springframework.org/schema/c"
	xmlns:cache="http://www.springframework.org/schema/cache"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jdbc="http://www.springframework.org/schema/jdbc"
	xmlns:jee="http://www.springframework.org/schema/jee"
	xmlns:lang="http://www.springframework.org/schema/lang"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:task="http://www.springframework.org/schema/task"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
		http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-4.2.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd
		http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.2.xsd
		http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.2.xsd
		http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-4.2.xsd
		http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd
		http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.2.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd">

------------------------------------------------------------------------------------------------------------------------------------

	// 스프링 설정 파일 이름은 무엇이든 상관 없지만 <beans>를 루트 엘리먼트로 사용해야 한다.
	
	

	// <import>엘리먼트는  트랜잭션 관리, 예외 처리, 다국어 처리 등 여러 설정을 할 때 기능별로 xml 파일을 나누는데 이렇게 분리한 설정 파일을 하나로 통합할 때 사용한다.
	<import resource="context-datasource.xml"/>
	<import resource="context-transaction.xml"/>
	
	
	
	// 스프링 설정 파일에 클래스를 등록하려면 <bean> 엘리먼트를 사용한다. 
	<bean id="test" class="com.myproject.webapp.test.Test" init-method="initMethod" destroy-method="destroyMethod" lazy-init="true"
		  scope(설정 안하면 singletonrk default)="singleton or prototype"></bean>
	
	
	
	// 스프링 프레임워크의 가장 중요한 특징은 객체의 생성과 의존관계를 컨테이너가 자동으로 관리한다는 것이다. 이것이 스프링 IoC(제어의 역전)의 핵심이다.
	// 의존성 주입은 컨테이너가 스프링 설정 파일에 등록된 정보를 바탕으로 직접 객체들 사이의 의존관계를 처리하는 것을 의미한다. 생성자 인젝션과 세터 인젝션이 있다. 
	// 생성자 인젝션
	// 스프링 컨테이너는 xml 설정 파일에 등록된 클래스를 찾아서 객체를 생성할 때 기본적으로 매개변수가 없는 기본 생성자를 호출한다.
	// 매개변수를 가지는 생성자를 호출하려면 생성자 인젝션을 사용한다.
	// 아래 예시의 경우 SonySpeaker가 먼저 생성된 후 SamsungTV가 생성된다.
	<bean id="tv" class="polymorphism.SamsungTV">
		<constructor-arg ref="sony"></constructor-arg>
		<constructor-arg value="27000"></constructor-arg>
		
		// 생성자 오버로딩이 되어있다면 헷갈릴 수 있기 때문에 인덱스도 사용 가능하다
		<constructor-arg index="0" ref="sony"></constructor-arg>
		<constructor-arg index="1" value="27000"></constructor-arg>
	</bean>
	<bean id="sony" class="polymorphism.SonySpeaker"></bean>
	
	
	
	// 세터 인젝션
	// 코딩 컨벤션에 따라 보통 세터 인젝션을 사용한다.( 세터 메소드가 제공되지 않는 클래스에 대해서만 생성자 인젝션 사용 )
	// 세터 메소드가 있어야 하고, bean 객체 생성 후에 세터 인젝션이 적용되므로 기본 생성자도 있어야 함
	// name의 첫 글자를 대문자로 바꾸고 앞에 set을 붙인 메소드가 실행된다.
	<bean id="tv" class="polymorphism.SamsungTV">
		<property name="speaker" ref="sony"></property>  -> setSpeaker() 호출
		<property name="price" value="27000"></property>
	</bean>
	<bean id="sony" class="polymorphism.SonySpeaker"></bean>
	
	
	
	// 세터 인젝션을 설정할 때  p네임스페이스를 이용할 수 있다.
	// p네임스페이스는 별도의 schemaLocation이 없기 때문에 네임스페이스만 선언하면 된다.
	<beans xmlns="http://www.springframework.org/schema/beans"
		   ...
		   xmlns:p="http://www.springframework.org/schema/p"
		   ...
		   xsi:schemaLocation="http://www.spring...">
	
	// p네임스페이스를 선언하면 다음과 같이 세터 인젝션이 가능하다
	<bean id="tv" class="polymorphism.SamsungTV" p:speaker-ref="sony" p:price="27000"></bean>
	<bean id="sony" class="polymorphism.SonySpeaker"></bean>
	
	
	
	// 배열, 컬렉션 객체 설정
	// 배열, java.util.List 타입 객체 세터 인젝션( private List<String> addressList; 라고 가정)
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<list>
				<value>서울시 강남구 역삼동</value>
				<value>서울시 성동구 행당동</value>
			</list>
		</property>
	</bean>
	
	// java.util.Set 타입 객체 세터 인젝션( private Set<String> addressList; 라고 가정)
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<set value-type="java.lang.String">
				<value>서울시 강남구 역삼동</value>
				<value>서울시 성동구 행당동</value>
				<value>서울시 성동구 행당동</value> -> Set이라 저장 안 됨
			</set>
		</property>
	</bean>
	
	// java.util.Map 타입 객체 세터 인젝션( private Map<String, Controller> addressList; 라고 가정)
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<map>
				<entry>
					<key><value>고길동</value></key>
					<value>서울시 강남구 역삼동</value>
				</entry>
				<entry>
					<key><value>마이콜</value></key>
					<value>서울시 성동구 성수동</value>
				</entry>
			</map>
		</property>
	</bean>
	
	// java.util.Properties 타입 객체 세터 인젝션( private Properties addressList; 라고 가정)
	// Properties는  key=value 형태의 데이터
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<props>
				<prop key="고길동">서울시 강남구 역삼동</prop>
				<prop key="마이콜">서울시 성동구 성수동</prop>
			</props>
		</property>
	</bean>
	
	
	
	// 어노테이션 설정을 위한 context 네임스페이스 및 스키마 문서 위치 등록, 컴포넌트 스캔 설정
	<beans xmlns="http://www.springframework.org/schema/beans"
		   ...
		   xmlns:context="http://www.springframework.org/schema/context"
		   ...
		   xsi:schemaLocation="http://www.spring...
		   					   http://www.springframework.org/schema/context 
		   					   http://www.springframework.org/schema/context/spring-context-4.2.xsd">
	
	// com.myproject.webapp 패키지 및 그 이하의 패키지 전부 적용 
	<context:component-scan base-package="com.myproject.webapp"></context:component-scan>
	
	// 컴포넌트 스캔 설정을 하면  클래스 위에  @Component 어노테이션을 설정하면 스프링 컨테이너가 객체를 생성해준다. 당연히 기본 생성자가 있어야 한다.
	// id를 설정하려면  @Component("tv")와 같이 설정해주면 되고, 지정하지 않으면 컨테이너가 자동으로 이름을 설정한다.( 이름 규칙은 클래스 이름의 첫 글자를 소문자로 변경한 것이다. )
	
	// 의존성 주입을 지원하는 어노테이션은 [@Autowired, @Qualifier](스프링에서 제공), @Inject, @Resource가 있다.
	
	// @Autowired는 생성자, 메소드, 멤버변수 위에 모두 사용 가능하지만 보통 멤버변수 위에 선언한다.
	// 스프링 컨테이너는 멤버 변수 위에 붙은 @Autowired를 확인한 후 해당 변수의 타입을 체크하여 해당 타입 객체가 메모리에 존재하는지 확인 후 변수에 주입한다.
	// 해당 객체가 메모리에 없다면 NoSuchBeanDefinitionException을 발생시킨다.
	// 문제는 인터페이스 변수 위에 @Autowired가 있고, 메모리에 구현 클래스 객체가 여러 개 있을 때 발생한다.
	// 이런 문제를 해결하기 위해 @Autowired와 @Qualifier("sony")를 같이 설정해준다.
	// 참고로 어노테이션으로 주입하는 경우 세터메소드가 필요 없다.
	@Component("tv")
	public class LgTV implements TV {
		@Autowired
		@Qualifier("sony")
		private Speaker speaker;
		
		public LgTV() { }
	}
	
	// @Resource는 객체의 이름을 이용하여 의존성 주입을 처리한다. @Inject도 이름 기반의 의존성 주입을 한다.
	@Component("tv")
	public class LgTV implements TV {
		@Resource(name="sony")
		private Speaker speaker;
		
		public LgTV() { }
	}
	
	
	
	// <bean> 엘리먼트 등록과 어노테이션을 적절히 사용해주면 좋다.
	// 변경되지 않는 객체는 어노테이션으로 설정하고, 변경될 가능성이 있는 객체는  <bean> 엘리먼트로 설정한다.
	// 참고로 라이브러리 형태로 제공되는 클래스는 xml 설정만 가능한다.
	
	
	
	// Presentation_And_Business_Layer.png 파일 확인
	// 프레젠테이션 레이어는 사용자와의 커뮤니케이션을 담당하고, 비즈니스 레이어는 사용자의 요청에 대한 비즈니스 로직 처리를 담당한다.
	// 이 구조에서 핵심은 Controller, ServiceImpl, DAO 클래스이다.
	// Controller : 사용자 요청 제어,  ServiceImpl: 비즈니스 로직 처리,   DAO : DB연동
	// 스프링 프레임워크에서는 이런 클래스들을 구분하기 위해  @Component를 상속한 3개의 어노테이션을 추가로 제공하고 각각 특별한 기능을 가지고 있다.
	-------------------------------------------------------------------------
	|	어노테이션		|		위치			|				의미					|
	-------------------------------------------------------------------------
	| @Service		| XXXServiceImpl	| 비즈니스 로직을 처리하는 Service 클래스		|
	-------------------------------------------------------------------------
	| @Repository	| XXXDAO			| DB연동을 처리하는 DAO 클래스				|
	-------------------------------------------------------------------------
	| @Controller	| XXXController		| 사용자 요청을 제어하는 Controller 클래스		|
	-------------------------------------------------------------------------
	
	
	
	// VO 클래스는 레이어와 레이어 사이에서 관련된 데이터를 한 번에 주고받을 목적으로 사용한다.
	// 하나의 테이블마다 하나의 VO 클래스가 있고, 테이블이름 뒤에 VO 붙인다.
	// 필드도 컬럼 이름과 타입에 맞게 private로 설정하고 게터/세터 메소드를 만들어주면 된다.
	
	
	
	// DAO 클래스는 DB 연동을 담당한다. CRUD 기능의 메소드를 구현하면 된다. @Repository("XXXDAO") 어노테이션을 지정해준다.
	// CRUD 기능 메소드 이름은 기능+테이블명으로 지정한다.( insert, update, delete, get, getXXXList 등 )
	
	
	
	// DB 연동을 위해 JDBC 드라이버가 필요하다. pom.xml에 작성한다.
	// oracle, mysql 관련 설정은 따로 찾아보기
	<!-- h2 database -->
	<dependency>
		<groupId>com.h2database</groupId>
		<artifactId>h2</artifactId>
		<version>2.1.212</version>
	</dependency>
	
	
	 
	// 서비스 인터페이스는 DAO 클래스에서  Alt+Shift+T를 눌러 쉽게 생성할 수 있다.(이클립스 기준)
	// 서비스 인터페이스를 구현한 서비스 XXXServiceImpl 클래스를 구현해준다.
	// @Service("XXXService") 어노테이션을 지정해주고, 필드의  private XXXDAO xxxDAO; 를 @Autowired 어노테이션으로 지정해준다.

------------------------------------------------------------------------------------------------------------------------------------
	
	// 비즈니스 컴포넌트 개발에서 중요한 두 가지는 낮은 결합도와 높은 응집도를 유지하는 것이다.
	// 스프링의 의존성 주입을 이용하면 비즈니스 컴포넌트를 구성하는 객체들의 결합도를 낮출 수 있다.
	// AOP는 응집도를 높일 수 있다.
	
	// AOP를 이해하는 데 가장 핵심 개념은 관심 분리이다.
	// AOP에서는 메소드마다 공통으로 등장하는 로깅이나 예외, 트랜잭션 처리 같은 코드들을 횡단 관심이라고 한다.
	// 이에 반해 사용자의 요청에 따라 실제로 수행되는 핵심 비즈니스 로직을 핵심 관심이라고 한다.
	
	
	
	// AOP를 적용하기 위해서 우선 pom.xml을 수정하여 AOP관련 라이브러리를 추가한다.
	<dependency>
		<groupId>org.aspectj</groupId>
		<artifactId>aspectjweaver</artifactId>
		<version>1.8.8</version>
	</dependency>
	
	// 스프링 설정 파일(applicationContext.xml)에서 aop 네임스페이스를 추가한다.
	<beans xmlns="http://www.springframework.org/schema/beans"
		   ...
		   xmlns:aop="http://www.springframework.org/schema/aop"
		   ...
		   xsi:schemaLocation="http://www.spring...
		   					   http://www.springframework.org/schema/aop 
		   					   http://www.springframework.org/schema/aop/spring-aop-4.2.xsd">
	
	// 이제 aop 관련 설정을 작성한다.
	// 아래 설정은 allPointcut으로 설정한 포인트컷 메소드가 호출되면 log라는 어드바이스 객체의 printLog 메소드가 실행되고 이때 printLog의 동작 시점은 before라는 뜻이다.
	<bean id="log" class="com.springbook.biz.comm.LogAdvice"></bean>
	<aop:config>
		<aop:pointcut id="allPointcut" expression="execution( * com.springbook.biz..*Impl.*(..) )"/>
		<aop:aspect ref="log">
			<aop:before pointcut-ref="allPointcut" method="printLog"/>
		</aop:aspect>
	</aop:config>
	
	
	
	// 조인포인트 : 클라이언트가 호출하는 모든 비즈니스 메소드. XXXServiceImpl 클래스의 모든 메소드가 조인포인트라고 생각하면 된다.
	// 포인트컷 : 횡단 관심을 적용시킬 필터링된 조인포인트이다. 핵심 관심이라고 보면 된다.
	// 어드바이스 : 횡단 관심에 해당하는 공통 기능의 코드이다. 어드바이스 동작 시점은  before, after-returning, after-throwing, after, around가 있다.
	// 위빙 : 포인트컷으로 지정한 핵심 관심 메소드가 호출될 때, 어드바이스에 해당하는 횡단 관심 메소드가 삽입되는 과정을 의미한다.
	
	// AOP(Aspect Oriented Programming)이라는 이름에서 알 수 있듯이 AOP의 핵심은 애스팩트이다.
	// 애스팩트는 포인트컷과 어드바이스의 결합이다. 어떤 포인트컷 메소드에 대해 어떤 어드바이스 메소드를 실행할지 결정한다. 
	
	
	
	// AOP 설정에서 <aop:config>는 루트 엘리먼트이다. 스프링 설정 파일 내에 여러번 사용할 수 있고, 하위에는 <aop:pointcut>, <aop:aspect>가 위치할 수 있다. 
	// <aop:pointcut> 엘리먼트는 포인트컷을 지정할 때 사용한다. 만약 <aop:aspect> 하위에 설정되면 해당 <aop:aspect>에서만 사용 가능하다.
	// 애스팩트는 <aop:aspect> 엘리먼트로 설정하며, 핵심 관심에 해당하는 포인트컷 메소드와 횡단 관심에 해당하는 어드바이스 메소드를 결합하기 위해 사용한다. 
	// 만약 어드바이스 객체의 아이디를 모르거나 메소드 이름을 확인할 수 없을 경우 애스팩트를 설정할 수 없다. 이런 경우 <aop:advisor> 엘리먼트를 사용한다.
	
	
	
	// 포인트컷 표현식
	// execution( * com.springbook.biz..*Impl.*(..) )
	
	// 리턴타입 지정
	-------------------------------------------------------------------------
	|	표현식	|				설명											|
	-------------------------------------------------------------------------
	| *			| 모든 리턴타입 허용												|
	-------------------------------------------------------------------------
	| void		| 리턴타입이 void인 메소드 선택										|
	-------------------------------------------------------------------------
	| !void		| 리턴 타입이 void가 아닌 메소드 선택									|
	-------------------------------------------------------------------------	
	
	// 패키지 지정
	-------------------------------------------------------------------------------------------------
	|	표현식						|				설명												|
	-------------------------------------------------------------------------------------------------
	| com.springbook.biz			| 정확하게 com.springbook.biz 패키지만 선택								|
	-------------------------------------------------------------------------------------------------
	| com.springbook.biz..			| com.springbook.biz 패키지로 시작하는 모든 패키지 선택						|
	-------------------------------------------------------------------------------------------------
	| com.springbook..impl			| com.springbook 패키지로 시작하면서 마지막 패키지 이름이 impl로 끝나는 패키지 선택	|
	-------------------------------------------------------------------------------------------------
	
	// 클래스 지정
	-----------------------------------------------------------------------------
	|	표현식			|				설명										|
	-----------------------------------------------------------------------------
	| BoardServiceImpl	| 정확하게 BoardServiceImpl 클래스만 선택						|
	-----------------------------------------------------------------------------
	| *Impl				| 클래스 이름이 Impl로 끝나는 클래스만 선택							|
	-----------------------------------------------------------------------------
	| BoardService+		| 클래스 이름 뒤에 '+'가 붙으면 해당 클래스로부터 파생된 모든 자식 클래스 선택. 	|
	|					| 인터페이스 뒤에 '+'가 붙으면 해당 인터페이스를 구현한 모든 클래스 선택			|
	-----------------------------------------------------------------------------
	
	// 메소드 지정
	-------------------------------------------------------------------------
	|	표현식	|				설명											|
	-------------------------------------------------------------------------
	| *(..)		| 가장 기본 설정으로 모든 메소드 선택									|
	-------------------------------------------------------------------------
	| get*(..)	| 메소드 이름이 get으로 시작하는 모든 메소드 선택							|
	-------------------------------------------------------------------------

	// 매개변수 지정
	-------------------------------------------------------------------------------------------------
	|	표현식						|				설명												|
	-------------------------------------------------------------------------------------------------
	| (..)							| 가장 기본 설정으로 '..'은 매개변수의 개수와 타입에 제약이 없음을 의미					|
	-------------------------------------------------------------------------------------------------
	| (*)							| 반드시 1개의 매개변수를 가지는 메소드만 선택									|
	-------------------------------------------------------------------------------------------------
	| (com.springbook.user.UserVO)	| 매개변수로 UserVO를 가지는 메소드만 선택. 패키지 경로가 포함되어야 함				|
	-------------------------------------------------------------------------------------------------
	| (!com.springbook.user.UserVO)	| 매개변수로 UserVO를 가지지 않는 메소드만 선택								|
	-------------------------------------------------------------------------------------------------
	| (Integer, ..)					| 한 개 이상의 매개변수를 가지되, 첫 번째 매개변수의 타입이 Integer인 메소드만 선택		|
	-------------------------------------------------------------------------------------------------
	| (Integer, *)					| 반드시 두 개의 매개변수를 가지되, 첫 번째 매개변수의 타입이 Integer인 메소드만 선택		|
	-------------------------------------------------------------------------------------------------
	
	
	
	// 어드바이스 동작 시점
	-------------------------------------------------------------------------------------------------
	|	동작 시점			|				설명															|
	-------------------------------------------------------------------------------------------------
	| Before			| 비즈니스 메소드 실행 전 동작															|
	-------------------------------------------------------------------------------------------------
	| After Returning	| 비즈니스 메소드가 성공적으로 리턴되면 동작												|
	-------------------------------------------------------------------------------------------------
	| After Throwing	| 비즈니스 메소드 실행 중 예외가 발생하면 동작(try ~ catch 블록에서 catch 블록에 해당)				|
	-------------------------------------------------------------------------------------------------
	| After				| 비즈니스 메소드 실행된 후, 무조건 실행(try ~ catch ~ finally 블록에서 finally 블록에 해당)	|
	-------------------------------------------------------------------------------------------------
	| Around			| 메소드 호출 자체를 가로채 비즈니스 메소드 실행 전후에 처리할 로직을 삽입할 수 있음						|
	-------------------------------------------------------------------------------------------------
	// 참고로 예외가 발생한 상황에서도 <aop:after>가 먼저 적용된다.
	// Around 어드바이스는 클라이언트의 메소드 호출을 가로챈 후 해당 비즈니스 메소드가 실행되기 전에 사전 처리 로직을 수행할 수 있고 비즈니스 메소드 실행 후에 사후 처리 로직을 수행할 수 있다.
	// 사전 처리 로직은 Before 어드바이스와 동일하게 동작하고, 사후 처리 로직은 After 어드바이스와 동일하게 동작한다.
	public class AroundAdvice {
		public Object aroundLog(ProceedingJoinPoint pjp) throws Throwable {
			// 사전 처리 로직
			Object obj = pjp.proceed();
			// 사후 처리 로직
			return obj;
		}
	}
	
	
	
	// 횡단 관심에 해당하는 어드바이스 메소드를 의미 있게 구현하려면 클라이언트가 호출한 비즈니스 메소드의 정보가 필요하다.
	// 스프링에서는 비즈니스 메소드의 다양한 정보를 이용할 수 있도록 JoinPoint 인터페이스를 제공한다.
	// 주의할 점은 Around 어드바이스에서는 ProceedingJoinPoint를 사용해야 한다.(JoinPoint를 상속하고 proceed()를 추가했다)
	// JoinPoint에서 제공하는 메소드
	-----------------------------------------------------------------------------------------------------
	|	메소드					|				설명														|
	-----------------------------------------------------------------------------------------------------
	| Signature getSignature()	| 클라이언트가 호출한 메소드의 시그니처(리턴타입, 이름, 매개변수) 정보가 저장된 Signature 객체 리턴	|
	-----------------------------------------------------------------------------------------------------
	| Object getTarget()		| 클라이언트가 호출한 비즈니스 메소드를 포함하는 비즈니스 객체 리턴								|
	-----------------------------------------------------------------------------------------------------
	| Object[] getArgs()		| 클라이언트가 메소드를 호출할 때 넘겨준 인자 목록을 Object 배열로 리턴						|
	-----------------------------------------------------------------------------------------------------
	
	
	
	// getSignature() 메소드가 리턴하는 Signature 객체를 이용하면, 호출되는 메소드에 대한 다양한 정보를 얻을 수 있다.
	// Signature가 제공하는 메소드
	-----------------------------------------------------------------------------------------------------
	|	메소드					|				설명														|
	-----------------------------------------------------------------------------------------------------
	| String getName()			| 클라이언트가 호출한 메소드 이름 리턴												|
	-----------------------------------------------------------------------------------------------------
	| String toLongString()		| 클라이언트가 호출한 메소드의 리턴타입, 이름, 매개변수를 패키지 경로까지 포함하여 리턴				|
	-----------------------------------------------------------------------------------------------------
	| String toShortString()	| 클라이언트가 호출한 메소드 시그니처를 축약한 문자열로 리턴									|
	-----------------------------------------------------------------------------------------------------
	
	
	
	// JoinPoint 객체를 사용하려면 JoinPoint를 어드바이스 메소드 매개변수로 선언하면 된다.
	// 그러면 클라이언트가 비즈니스 메소드를 호출할 때, 스프링 컨테이너가 JoinPoint 객체를 생성한다.
	// 그리고 메소드 호출과 관련된 모든 정보를 JoinPoint 객체에 저장하여 어드바이스 메소드를 호출할 때 인자로 넘겨준다.
	ex)
	public void beforeLog(JoinPoint jp) {
		String method = jp.getSignature().getName();
		Object[] args = jp.getArgs();
		System.out.println("메소드 : " + method + "(), 메소드 인자 : " + args[0].toString());
	}
	
	
	// After Returning 어드바이스 메소드에 바인드 변수가 추가됐다면 바인드 변수에 대한 매핑 설정을 스프링 설정 파일에 추가해야 한다.
	// <aop:after-returning pointcut-ref="allPointcut" method="afterLog" returning="returnObj"/>
	public void afterLog(JoinPoint jp, Object returnObj) { // Object returnObj -> 바인드 변수
		String method = jp.getSignature().getName();
		if (returnObj instanceof UserVO) {
			...
		}
		System.out.println("메소드 : " + method + "(), 메소드 리턴값 : " + returnObj.toString());
	}
	
	
	// After Throwing 어드바이스 메소드에 바인드 변수가 추가됐다면 바인드 변수에 대한 매핑 설정을 스프링 설정 파일에 추가해야 한다.
	// <aop:after-throwing pointcut-ref="allPointcut" method="exceptionLog" throwing="exceptionObj"/>
	public void exceptionLog(JoinPoint jp, Exception exceptionObj) { // Exception exceptionObj -> 바인드 변수
		String method = jp.getSignature().getName();
		System.out.println("메소드 : " + method + "(), 메소드 수행 중 발생한 예외 메시지 : " + exceptionObj.getMessage());
	}
	
	
	
	// AOP도 IoC와 마찬가지로 어노테이션 설정을 지원한다.
	// 스프링 설정 파일에 <aop:aspectj-autoproxy> 엘리먼트만 선언하면 스프링 컨테이너는 AOP 관련 어노테이션들을 인식하고 용도에 맞게 처리해준다.
	
	// AOP 관련 어노테이션은 어드바이스 클래스에 설정한다.
	// 어노테이션 설정으로 포인트컷을 선언할 때는  @Pointcut을 사용하며 포인트컷을 식별하기 위한 참조 메소드를 이용한다.
	@Pointcut("execution( * com.springbook.biz..*Impl.*(..) )")
	public void allPointcut() {}
	
	// 어드바이스 클래스에는 횡단 관심에 해당하는 어드바이스 메소드가 있다.
	// 이 어드바이스 메소드가 언제 동작할지 결정하여 관련된 어노테이션을 메소드 위에 설정하면 된다.
	@Before("allPointcut()")
	public void printLog() {...}
	
	// 다음은 어드바이스 동작 시점과 관련된 어노테이션이다.
	// @Before,  @AfterReturning,  @AfterThrowing,  @After,  @Around
	
	// 애스팩트는 @Aspect를 이용하여 설정한다.
	// 애스팩트는 포인트컷과 어드바이스의 결합이다. 따라서 @Aspect가 설정된 애스팩트 객체에는 반드시 포인트컷과 어드바이스를 결합하는 설정이 있어야 한다.
	
	// 어드바이스 클래스마다 포인트컷 설정을 하지 않으려면 포인트컷을 외부에 독립된 클래스에 따로 설정하면 된다.
	@Aspect
	public class PointcutCommon {
		@Pointcut("execution( * com.springbook.biz..*Impl.*(..) )")
		public void allPointcut() {}
		
		@Pointcut("execution( * com.springbook.biz..*Impl.get*(..) )")
		public void getPointcut() {}
	}
	
	// 아래는 어드바이스 클래스 예시이다.
	@Service
	@Aspect
	public class BeforeAdvice {
		@Before("PointcutCommon.allPointcut()")
		public void beforeLog(JoinPoint jp) {
			String method = jp.getSignature().getName();
			Object[] args = jp.getArgs();
			System.out.println("메소드 : " + method + "(), 메소드 인자 : " + args[0].toString());
		}
	}
	
	
	@Service
	@Aspect
	public class AfterReturningAdvice {
		@AfterReturning(pointcut="PointcutCommon.allPointcut()", returning="returnObj")
		public void afterLog(JoinPoint jp, Object returnObj) { // Object returnObj -> 바인드 변수
			String method = jp.getSignature().getName();
			if (returnObj instanceof UserVO) {
				...
			}
			System.out.println("메소드 : " + method + "(), 메소드 리턴값 : " + returnObj.toString());
		}
	}
	
	
	@Service
	@Aspect
	public class AfterThrowingAdvice {
		@AfterThrowing(pointcut="PointcutCommon.allPointcut()", throwing="exceptionObj")
		public void exceptionLog(JoinPoint jp, Exception exceptionObj) { // Exception exceptionObj -> 바인드 변수
			String method = jp.getSignature().getName();
			System.out.println("메소드 : " + method + "(), 메소드 수행 중 발생한 예외 메시지 : " + exceptionObj.getMessage());
		}
	}
	
	
	@Service
	@Aspect
	public class AfterAdvice {
		@After("PointcutCommon.allPointcut()")
		public void finallyLog(JoinPoint jp) { 
			String method = jp.getSignature().getName();
			System.out.println("메소드 : " + method + "()");
		}
	}
	
	
	@Service
	@Aspect
	public class AroundAdvice {
		@Around("PointcutCommon.allPointcut()")
		public Object aroundLog(ProceedingJoinPoint pjp) throws Throwable {
			// 사전 처리 로직
			Object obj = pjp.proceed();
			// 사후 처리 로직
			return obj;
		}
	}
	
	
	
	// JDBC를 이용하여 DB 연동 프로그램을 개발하면 비슷한 코드를 SQL만 바꿔 사용하는 경우가 대부분이다.
	// 스프링은 JDBC 기반의 DB 연동 프로그램을 쉽게 개발할 수 있도록 JdbcTemplage 클래스를 지원한다.
	
	// JdbcTemplate은  GoF 디자인 패턴 중 템플릿 메소드 패턴이 적용된 클래스이다.
	// 템플릿 메소드 패턴은 복잡하고 반복되는 알고리즘을 캡슐화해서 재사용하는 패턴으로 정의할 수 있다. 즉, JDBC처럼 코딩 순서가 정형화된 기술에서 유용하다.
	// 반복되는 DB 연동 로직은 JdbcTemplate 클래스의 템플릿 메소드가 제공하고, 개발자는 달라지는 SQL 구문과 설정값만 신경 쓰면 된다.
	
	// 스프링 JDBC를 이용하려면 pox.xml 파일에 DBCP 관련 <dependency>를 추가한다.
	<!-- Spring -->
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-jdbc</artifactId>
		<version>${org.springframework-version}</version>
	</dependency>
	
	<!-- DBCP -->
	<dependency>
		<groupId>commons-dbcp</groupId>
		<artifactId>commons-dbcp</artifactId>
		<version>1.4</version>
	</dependency>
	
	
	
	// JdbcTemplate가 JDBC API를 이용하여  DB 연동을 처리하려면 반드시  DB로부터 커넥션을 얻어야 한다.
	// 따라서 JdbcTemplate 객체가 사용할 DataSource를 <bean> 등록하여 스프링 컨테이너가 생성하도록 해야 한다.
	<!-- DataSource 설정 -->
	<bean id="dataSource" class="org.apache.common.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="org.h2.Driver"/>
		<property name="url" value="jdbc:h2:tcp://localhost/~/test"/>
		<property name="username" value="sa"/>
		<property name="password" value=""/>
	</bean>
	
	
	
	// PropertyPlaceholderConfigurer를 이용하면 외부의 프로퍼티 파일을 참조하여 DataSource를 설정할 수 있다.
	// src/main/resources 소스 폴더에 config 폴더를 생성하고 폴더 안에 database.properties 파일을 작성하였다.
	jdbc.driver=org.h2.Driver
	jdbc.url=jdbc:h2:tcp://localhost/~/test
	jdbc.username=sa
	jdbc.password=
	
	// 이제 Properties 파일에 설정된 프로퍼티들을 이용하여 DataSource를 설정하려면 다음과 같이 설정한다.
	<!-- DataSource 설정 -->
	<context:property-placeholder location="classpath:config/database.properties"/>
	
	<bean id="dataSource" class="org.apache.common.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="${jdbc.driver}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>	
	
	
	
	// 스프링 JDBC 설정이 되었으니 이제 JdbcTemplate 객체를 이용하여 DB 연동을 처리할 수 있다.
	// 쿼리의 ? 부분에 값을 차례로 나열하거나 값이 세팅되어 있는 배열 객체를 전달하는 방식이 있다.
	
	// insert, update, delete 구문을 처리할 때는 JdbcTemplate 클래스의 update() 메소드를 사용한다.
	-----------------------------------------------------------------------------------------------------------------
	|	메소드	|	int update(String sql, Object...args)															|
	-----------------------------------------------------------------------------------------------------------------
	| 	사용 예	| 	// 글 수정																							|
	|			|	public void updateBoard(BoardVO vo) {															|
	|			|		String BOARD_UPDATE = update board set title=?, content=? where seq=?";						|
	|			|		int cnt = jdbcTemplate.upate(BOARD_UPDATE, vo.getTitle(), vo.getContent(), vo.getSeq());	|
	|			|		System.out.println(cnt + "건 데이터 수정");														|
	|			|	}																								|
	-----------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------
	|	메소드	|	int update(String sql, Object[] args)															|
	-----------------------------------------------------------------------------------------------------------------
	| 	사용 예	| 	// 글 수정																							|
	|			|	public void updateBoard(BoardVO vo) {															|
	|			|		String BOARD_UPDATE = update board set title=?, content=? where seq=?";						|
	|			|		Object[] args = {vo.getTitle(), vo.getContent(), vo.getSeq()};								|
	|			|		int cnt = jdbcTemplate.upate(BOARD_UPDATE, args);											|
	|			|		System.out.println(cnt + "건 데이터 수정");														|
	|			|	}																								|
	-----------------------------------------------------------------------------------------------------------------	
	
	
	// select 구문으로 검색된 정수값을 리턴받으려면 queryForInt() 메소드를 사용한다.
	-----------------------------------------------------------------------------------------------------------------
	|	메소드	|	int queryForInt(String sql)																		|
	|			|	int queryForInt(String sql, Object...args)														|
	|			|	int queryForInt(String sql, Object[] args)														|
	-----------------------------------------------------------------------------------------------------------------
	| 	사용 예	| 	// 전체 게시글 수 조회																					|
	|			|	public void getBoardTotalCount(BoardVO vo) {													|
	|			|		String BOARD_TOT_COUNT = "select count(*) from board";										|
	|			|		int cnt = jdbcTemplate.queryForInt(BOARD_TOT_COUNT);										|
	|			|		System.out.println("전체 게시글 수 : " + cnt + "건");												|
	|			|	}																								|
	-----------------------------------------------------------------------------------------------------------------
	
	
	// select 구문의 실행 결과를 특정 자바 객체로 매핑하여 리턴받을 때는 queryForObject()를 사용한다.
	// queryForObject()는 검색 결과가 없거나 검색 결과가 두 개 이상이면 예외( IncorrectResultSizeDataAccessException )를 발생시킨다.
	// 그리고 검색 결과를 자바 객체로 매핑할 RowMapper 객체를 반드시 지정해야 한다.
	-----------------------------------------------------------------------------------------------------------------
	|	메소드	|	Object queryForObject(String sql)																|
	|			|	Object queryForObject(String sql, RowMapper<T> rowMapper)										|
	|			|	Object queryForObject(String sql, Object[] args, RowMapper<T> rowMapper)						|
	-----------------------------------------------------------------------------------------------------------------
	| 	사용 예	| 	// 글 상세 조회																						|
	|			|	public BoardVO getBoardTotalCount(BoardVO vo) {													|
	|			|		String BOARD_GET = "select * from board where seq=?";										|
	|			|		Object[] args = {vo.getSeq()};																|
	|			|		return jdbcTemplate.queryForObject(BOARD_GET, args, new BoardRowMapper());					|
	|			|	}																								|
	-----------------------------------------------------------------------------------------------------------------
	
	// 검색 결과를 특정 VO 객체에 매핑하여 리턴하려면  RowMapper 인터페이스를 구현한 클래스가 필요하다. 결국 RowMapper 클래스는 테이블당 하나씩은 필요하다는 뜻이다.
	// RowMapper 객체를 queryForObject() 메소드의 매개변수로 넘겨주면, 스프링 컨테이너는 SQL 구문을 수행한 후 자동으로 RowMapper 객체의 mapRow() 메소드를 호출한다. 
	// RowMapper 인터페이스에는 mapRow() 메소드가 있어서 검색 결과로 얻어낸 row 정보를 어떤 VO에 어떻게 매핑할 것인지를 구현해주면 된다.
	public class BoardRowMapper implements RowMapper<BoardVO> {
		public BoardVO mapRow(ResultSet rs, int rowNum) throws SQLException {
			BoardVO board = new BoardVO();
			board.setSeq(rs.getInt("seq"));	
			board.setSeq(rs.getInt("title"));	
			...
			return board;
		}
	}
	
	
	// select 구문의 결과가 목록일 때는 query() 메소드를 사용한다.
	// 검색된 데이터 row 수만큼 RowMapper 객체의 mapRow() 메소드가 실행된다. 이렇게 row 정보가 매핑된 VO객체 여러 개가 List 컬렉션에 저장되어 리턴된다.
	-----------------------------------------------------------------------------------------------------------------
	|	메소드	|	List query(String sql)																			|
	|			|	List query(String sql, RowMapper<T> rowMapper)													|
	|			|	List query(String sql, Object[] args, RowMapper<T> rowMapper)									|
	-----------------------------------------------------------------------------------------------------------------
	| 	사용 예	| 	// 글 목록 조회																						|
	|			|	public List<BoardVO> getBoardList(BoardVO vo) {													|
	|			|		String BOARD_LIST = "select * from board order by seq desc";								|
	|			|		return jdbcTemplate.query(BOARD_LIST, new BoardRowMapper());								|
	|			|	}																								|
	-----------------------------------------------------------------------------------------------------------------
	

	
	// JdbcTemplate 객체를 이용하여 DAO 클래스를 구현하려면 두 가지 방법이 있다.
	// 1. JdbcDaoSupport 클래스 상속
	// JdbcDaoSupport 클래스를 상속받으면 getJdbcTemplate() 메소드를 상속받을 수 있다.
	// 단, DataSource 객체를 의존성 주입해야 한다.
	// @Autowired 어노테이션은 주로 변수 위에 선언하기는 하지만, 메소드 위에 선언해도 스프링 컨테이너가 매개변수 타입을 확인하고 해당 타입 객체를 메모리에서 확인하여 인자로 넘겨준다.
	@Repository
	public class BoardDaoSpring extends JdbcDaoSupport {
		private final String BOARD_INSERT = "insert into...";
		...
		
		@Autowired
		public void setSuperDataSource(DataSource dataSource) {
			super.setDataSource(dataSource);
		}
	
		public void insetBoard(BoardVO vo) {
			getJdbcTemplate().update(BOARD_INSERT, vo.getTitle(), vo.getWriter(), vo.getContect());
		}
		...
	}
	
	
	// 2. JdbcTemplate 클래스 <bean> 등록, 의존성 주입( 일반적으로 이 방법을 사용한다 )
	<!-- DataSource 설정 -->
	<bean id="dataSource" class="org.apache.common.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="org.h2.Driver"/>
		<property name="url" value="jdbc:h2:tcp://localhost/~/test"/>
		<property name="username" value="sa"/>
		<property name="password" value=""/>
	</bean>
	
	<!-- Spring JDBC 설정 -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource"/>
	</bean>
	
	@Repository
	public class BoardDaoSpring {
		@Autowired
		private JdbcTemplate jdbcTemplate;
	
		private final String BOARD_INSERT = "insert into...";
		...
	
		public void insetBoard(BoardVO vo) {
			jdbcTemplate.update(BOARD_INSERT, vo.getTitle(), vo.getWriter(), vo.getContect());
		}
		...
	}
	
	
	
	// 스프링에서 트랜잭션 처리를 컨테이너가 자동으로 처리하도록 설정할 수 있는데, 이를 선언적 트랜잭션 처리라 한다.
	// 스프링 트랜잭션 설정에서는 <aop:advisor> 엘리먼트를 사용한다.
	// 스프링 설정 파일에 트랜잭션 관련 네임스페이스를 추가해야 한다.
	<beans xmlns="http://www.springframework.org/schema/beans"
		   ...
		   xmlns:aop="http://www.springframework.org/schema/aop"
		   xmlns:aop="http://www.springframework.org/schema/tx"
		   ...
		   xsi:schemaLocation="http://www.spring...
		   					   http://www.springframework.org/schema/aop 
		   					   http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
		   					   http://www.springframework.org/schema/tx
		   					   http://www.springframework.org/schema/tx/spring-tx-4.2.xsd">	
	
	// 트랜잭션 관련 설정에서 가장 먼저 등록하는 것은 트랜잭션 관리자 클래스이다.
	// 모든 트랜잭션 관리자는 PlatformTransactionManager 인터페이스를 구현한 클래스이다.
	public interface PlatformTransactionManager {
		TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
		void commit(TransactionStatus status) throws TransactionException;
		void rollback(TransactionStatus status) throws TransactionException;
	}
	
	// 당분간은 DataSourceTransactionManager 클래스를 이용하여 트랜잭션을 처리할 것이다.
	// 이후에 JPA를 이용하여 DAO 클래스를 구현한다면 JPATransactionManager를 등록하면 된다.
	<!-- DataSource 설정 -->
	<bean id="dataSource" class="org.apache.common.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="org.h2.Driver"/>
		<property name="url" value="jdbc:h2:tcp://localhost/~/test"/>
		<property name="username" value="sa"/>
		<property name="password" value=""/>
	</bean>
	
	<!-- Transaction 설정 -->
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>
	
	// 우리는 비즈니스 메소드가 실행하다가 예외가 발생하면 해당 메소드에 대한 트랜잭션을 rollback하고, 정상 종료되면 해당 메소드에 대한 트랜잭션을 commit하면 된다.
	// 트랜잭션을 commit, rollback 하기 위한 객체가 DataSourceTransactionManager이므로 이제 이 트랜잭션 관리자를 이용하여 트랜잭션을 제어하는 어드바이스를 등록한다.
	
	// 트랜잭션 관리 기능의 어드바이스는 스프링 설정 파일에 <tx:advice> 엘리먼트를 사용하여 설정한다.
	<!-- Transaction 설정 -->
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>
	
	<!-- Transaction 어드바이스 설정 -->
	<tx:advice id="txAdvice" transaction-manager="txManager">
		<tx:attributes>
			<tx:method name="get* read-only="true"/>
			<tx:method name="*"/>
		</tx:attributes>
	</tx:advice>
	
	// 이전에는 AOP 관련 설정에 사용한 어드바이스는 직접 구현했었다.
	// 하지만 트랜잭션 관리 기능의 어드바이스는 스프링 컨테이너가 <tx:advice> 설정을 참조하여 자동으로 생성한다.
	// 이 말은 트랜잭션 관리 어드바이스 객체의 클래스 이름이나 메소드를 확인할 수 없다는 뜻이기도 하다.
	// 우리가 할 수 있는 것은 단지 생성되는 어드바이스 아이디를 id속성으로, 어드바이스 객체가 사용할 트랜잭션 관리자를 transaction-manager 속성으로 지정할 뿐이다.
	
	// <tx:attributes>의 자식 엘리먼트로 <tx:method> 엘리먼트를 이용하여 트랜잭션을 적용할 메소드를 지정할 수 있다.
	// 위 설정은 get으로 시작하는 모든 메소드는 읽기 전용으로 처리되어 트랜잭션 관리 대상에서 제외하고 나머지 메소드들은 트랜잭션 관리에 포함한 것이다.
	// 다음은 <tx:method> 엘리먼트가 가질 수 있는 속성 값이다.
	-----------------------------------------------------------------------------------------------------
	|	속성				|				의미																|
	-----------------------------------------------------------------------------------------------------
	| name				| 트랜잭션이 적용될 메소드 이름															|
	-----------------------------------------------------------------------------------------------------
	| read-only			| 읽기 전용 여부 지정(기본값 false)														|
	-----------------------------------------------------------------------------------------------------
	| no-rollback-for	| 트랜잭션을 롤백하지 않을 예외 지정															|
	-----------------------------------------------------------------------------------------------------
	| rollback-for		| 트랜잭션을 롤백할 예외 지정																|
	-----------------------------------------------------------------------------------------------------	
	
	
	
	// 트랜잭션 관리 어드바이스까지 설정했으면 비즈니스 메소드 실행 후에 트랜잭션 관리 어드바이스가 동작하도록 AOP 설정을 하면 된다.
	// 트랜잭션 관리 어드바이스는 우리가 직접 클래스를 구현하지 않고, <tx:advice> 설정을 통해 스프링 컨테이너가 자동으로 생성하므로 어드바이스 메소드 이름을 알 수 없다.
	// 따라서 <aop:advisor> 엘리먼트를 사용한다.
	<tx:advice id="txAdvice" transaction-manager="txManager">
		<tx:attributes>
			<tx:method name="get* read-only="true"/>
			<tx:method name="*"/>
		</tx:attributes>
	</tx:advice>
	
	<aop:config>
		<aop:pointcut id="txPointcut" expression="execution( * com.springbook.biz..*(..) )"/>
		<aop:advisor pointcut-ref="txPointcut" advice-ref="txAdvice"/>
	</aop:config>
	
	
	
	// 결과적으로 트랜잭션 설정 관련 엘리먼트는 다음과 같다.
	<!-- DataSource 설정 -->
	<bean id="dataSource" class="org.apache.common.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="org.h2.Driver"/>
		<property name="url" value="jdbc:h2:tcp://localhost/~/test"/>
		<property name="username" value="sa"/>
		<property name="password" value=""/>
	</bean>
	
	<!-- Spring JDBC 설정 -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource"/>
	</bean>
	
	<!-- Transaction 설정 -->
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>
	
	<!-- Transaction 어드바이스 설정 -->
	<tx:advice id="txAdvice" transaction-manager="txManager">
		<tx:attributes>
			<tx:method name="get* read-only="true"/>
			<tx:method name="*"/>
		</tx:attributes>
	</tx:advice>
	
	<!-- AOP 설정 -->
	<aop:config>
		<aop:pointcut id="txPointcut" expression="execution( * com.springbook.biz..*(..) )"/>
		<aop:advisor pointcut-ref="txPointcut" advice-ref="txAdvice"/>
	</aop:config>
	
------------------------------------------------------------------------------------------------------------------------------------

	// Model 1 아키텍처는 JSP와 JavaBeans만 사용하여 웹을 개발하는 구조이다.
	// Model 1 아키텍처에서 우선 살펴볼 것이 Model 기능의 JavaBeans이다.
	// 자바에서 bean이라는 용어는 객체를 의미하므로 JavaBean은 자바 객체를 의미한다. 결국, JavaBeans는 데이터베이스 연동에 사용되는 자바 객체들이다.
	
	// 원래 Model의 정확한 의미는 데이터베이스 연동 로직을 제공하면서 DB에서 검색한 데이터가 저장되는 자바 객체다.
	// VO와 DAO 클래스가 Model 기능의 자바 객체다.
	
	// Model 1 아키텍처에서는 JSP 파일이 가장 중요한 역할을 수행하는데, JSP가 Controller와 View 기능을 모두 처리하기 때문이다.
	// 하지만 결과적으로 JSP 파일에 자바 코드와 마크업(html, css 등) 코드가 섞여 있어 역할 구분이 명확하지 않고, 유지보수가 어렵다.
	
	// 포워드와 리다이렉트 차이
	// 포워드 방식은 RequestDispatcher를 이용하여 응답으로 사용할 JSP 화면으로 넘겨서, 포워드된 화면이 클라이언트에 전송되는 방식이다.
	// 이 방식은 한 번의 요청과 응답으로 처리되어 속도는 빠르지만, 클라이언트 브라우저에서 url이 바뀌지 않아 응답이 어디에서 들어왔는지 확인할 수 없다.
	
	// 리다이렉트는 응답이 브라우저로 들어간 다음, 재요청하는 방식이다.
	// 브라우저의 url이 변경되지만, 두 번의 요청과 응답으로 처리되므로 속도는 포워드 방식보다 느리다.
	
	// Model 1 아키텍처의 문제를 해결하기 위해 고안된 것이 Model 2 아키텍처, 즉 MVC 아키텍처이다.
	// MVC 아키텍처에서 가장 중요한 특징은 Controller의 등장이며, Controller는 서블릿 클래스를 중심으로 구현한다.
	
	// MVC 아키텍처 각 요소의 기능과 개발 주체를 정리한 표이다.
	-----------------------------------------------------------------------------------------------------
	|	기능				|				의미					|				개발 주체						|
	-----------------------------------------------------------------------------------------------------
	| Model				| VO, DAO 클래스						|				자바 개발자						|
	-----------------------------------------------------------------------------------------------------
	| View				| JSP 페이지							|				웹 디자이너						|
	-----------------------------------------------------------------------------------------------------
	| Controller		| Servlet 클래스						|				자바 개발자 or MVC 프레임워크		|
	-----------------------------------------------------------------------------------------------------
	
	
	
	// Controller 로직은 사용자 입력 정보 추출, Model을 이용한 DB 연동 처리, 화면 내비게이션에 해당하는 자바 코드를 의미한다.
	// Controller 기능을 수행하는 서블릿 클래스 예시를 보자
	// Servlet을 생성하면  WEB-INF/web.xml 파일에 서블릿 관련 설정이 자동으로 추가된다.
	// 아래 설정은 클라이언트의 모든 *.do 요청을 DispatcherServlet 클래스의 객체가 처리한다는 설정이다. 확장자 .do는 다른 이름을 써도 상관없다.
	<servlet>
		<servlet-name>action</servlet-name>
		<servlet-class>com.springbook.view.controller.DispatcherServlet</servlet-class>
	</servlet>
	
	<servlet-mapping>
		<servlet-name>action</servlet-name>
		<url-pattern>*.do</url-pattern>
	</servlet-mapping>
	
	// 아래는 생성한 Servlet 예시이다.
	public class DispatcherServlet extends HttpServlet {
		private static final long serialVersionUID = 1L;
	       
		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			process(request, response);
		}
	
		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			request.setCharacterEncoding("utf-8");
			process(request, response);
		}
		
		private void process(HttpServletRequest request, HttpServletResponse response) throws IOException {
			// controller 기능 수행
			String uri = request.getRequestURI();
			String path = uri.substring(uri.lastIndexOf("/"));
			
			if (path.equals("/login.do")) {
				...
			} else if(path.equals("/insertBoard.do")) {
				...
				if (user != null) 
					response.sendRedirect("getBoardList.do");
				else
					response.sendRedirect("login.jsp");
			} else if(path.equals("/updateBoard.do")) {
				...
			}	...
			
		}
	}
	
	
	
	// 위와 같이 DispatcherServlet 클래스 하나로 Controller 기능을 구현하면 클라이언트의 모든 요청을 하나의 서블릿이 처리하게 된다.
	// 이렇게 되면 특정 기능을 수정하려고 할 때 코드를 찾는 것부터 쉽지 않고, 새로운 기능을 추가할 때마다 분기 처리 로직은 계속 늘어난다.
	
	// 만약 프레임워크에서 제공하는 Controller를 사용한다면 개발자가 직접 Controller를 구현하지 않아도 된다.
	// Spring 같은 프레임워크를 사용하는 이유가 이런 프레임워크들이 Controller를 제공해주기 때문이다.
	// Spring MVC를 적용하기 전에 Spring MVC와 동일한 구조의 프레임워크를 직접 구현해보자.
	
	// MVC 프레임워크의 구조는  MVC Framework Architecture.png와 같다.
	// 각 클래스들의 역할은 다음과 같다.
	-----------------------------------------------------------------------------------------------------
	|	클래스				|				기능															|
	-----------------------------------------------------------------------------------------------------
	| DispatcherServlet		| 유일한 서블릿 클래스로서 모든 클라이언트의 요청을 가장 먼저 처리하는 Front Controller				|
	-----------------------------------------------------------------------------------------------------
	| HandlerMapping		| 클라이언트의 요청을 처리할 Controller 매핑											|
	-----------------------------------------------------------------------------------------------------
	| Controller			| 실질적인 클라이언트의 요청 처리														|
	-----------------------------------------------------------------------------------------------------	
	| ViewResolver			| Controller가 리턴한 View 이름으로 실행될 JSP 경로 완성									|
	-----------------------------------------------------------------------------------------------------		
	
	
	
	// DispatcherServlet은 클라이언트의 요청을 가장 먼저 받아들이는 Front Controller이다.
	// 하지만 하는 일은 거의 없으며, 실질적인 요청 처리는 각 Controller에서 담당한다.
	
	// 클라이언트의 요청을 받은 DispatcherServlet은 HandlerMapping을 통해 Controller 객체를 검색한 후 실행한다.
	// 구체적인 Controller 클래스들을 구현하기 앞서 모든 Controller를 같은 타입으로 관리하기 위한 인터페이스를 만든다.
	public interface Controller {
		String handleRequest(HttpServletRequest request, HttpServletResponse response);
	}
	
	
	// 이제 Controller 인터페이스를 구현한 각각의 구현 클래스를 만든다.
	// DispatcherServlet의 process() 메소드에 작성된 각각의 '.do' 요청에 해당하는 코드가 오면 된다.
	// 다만, Controller 인터페이스의 handleRequest()를 재정의했으므로 이동할 화면을 리턴하는 것으로 처리한다.
	// 또한 로그인 실패 시 이동할 화면 정보에 확장자가 없는데 이는 나중에 추가할 ViewResolver 클래스를 통해 처리할 수 있다.
	// 여기서는 그냥 확장자가 없는 문자열을 리턴하면, 자동으로 '.jsp'확장자가 붙어서 처리된다는 것으로 이해하고 넘어간다.
	public class LoginController implements Controller {
		@Override
		public String handleRequest(HttpServletRequest request, HttpServletResponse response) {
			...
			if (user != null) 
				return "getBoardList.do";
			else
				return "login";
		}
	}
	
	
	// HandlerMapping은 모든 Controller 객체들을 저장하고 있다가, 클라이언트의 요청이 들어오면 요청을 처리할 특정 Controller를 검색하는 기능을 제공한다.
	// HandlerMapping은 DispatcherServlet이 생성되고 init() 메소드를 호출할 때 단 한 번 생성된다.
	public class HandlerMapping {
		private Map<String, Controller> mappings;
		
		public HandlerMapping() {
			mappings = new HashMap<String, Controller>();
			mappings.put("/login.do", new LoginController());
			mappings.put("/insertBoard.do", new InsertBoardController());
			...
		}
		
		public Controller getController(String path) {
			return mappings.get(path);
		}
	}
	
	
	// ViewResolver 클래스는 Controller가 리턴한 View 이름에 접두사(prefix)와 접미사(Suffix)를 결합하여 최종적으로 실행될 View 경로와 파일명을 완성한다.
	// ViewResolver은 DispatcherServlet이 생성되고 init() 메소드를 호출할 때 단 한 번 생성된다.
	public class ViewResolver {
		public String prefix;
		public String suffix;
		
		public void setPrefix(String prefix) {
			this.prefix = prefix;
		}
		
		public void setSuffix(String suffix) {
			this.suffix = suffix;
		}
		
		public String getView(String viewName) {
			return prefix + viewName + suffix;
		}
	}
	
	
	// 이제 DispatcherServlet을 수정해보자
	// init() 메소드가 재정의되어 있는데 서블릿의 init() 메소드는 서블릿 객체가 생성된 후 멤버변수 초기화를 위해 자동으로 실행된다.
	public class DispatcherServlet extends HttpServlet {
		private static final long serialVersionUID = 1L;
		private HandlerMapping handlerMapping;
		private ViewResolver viewResolver;
		
		public void init() throws ServletException {
			handlerMapping = new HandlerMapping();
			viewResolver = new ViewResolver();
			viewResolver.setPrefix("./");
			viewResolver.setSuffix(".jsp");
		}
	       
		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			process(request, response);
		}
	
		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			request.setCharacterEncoding("utf-8");
			process(request, response);
		}
		
		private void process(HttpServletRequest request, HttpServletResponse response) throws IOException {
			// 1. 클라이언트의 요청 path 정보 추출
			String uri = request.getRequestURI();
			String path = uri.substring(uri.lastIndexOf("/"));
			
			// 2. HandlerMapping을 통해 path에 해당하는 Controller를 검색한다.
			Controller ctrl = handlerMapping.getController(path);
			
			// 3. 검색된 Controller를 실행한다.
			String viewName = ctrl.handleRequest(request, response);
			
			// 4. ViewResolver를 통해 viewName에 해당하는 화면을 검색한다.
			String view = null;
			if (!viewName.contains(".do") 
				view = viewResolver.getView(viewName);
			else
			view = viewName;
			
			// 5. 검색된 화면으로 이동한다.
			response.sendRedirect(view);
		}
	}	
	
	// Spring MVC와 동일한 구조의 프레임워크를 직접 구현해보았다.
	// 흐름을 정리하면 다음과 같다.
	1. 클라이언트로부터의 모든 '.do' 요청을 DispatcherServlet이 받는다.
	2. DispatcherServlet은 HandlerMapping을 통해 요청을 처리할 Controller를 검색한다.
	3. 검색된 Controller의  hendleRequest() 메소드를 실행하여 비즈니스 로직(클라이언트의 요청)을 처리한다.
	4. Controller는 비즈니스 로직의 수행 결과로 얻어낸 결과를 저장하고,  View 정보를 리턴한다.
	5. 최종적으로 JSP를 실행하여 실행 결과가 브라우저에 응답된다.
	
	
	
	// 지금은 직접 DispatcherServlet 클래스를 만들었지만 최종적으로는 스프링 프레임워크에서 제공하는 클래스를 사용할 것이다.
	// 그런데 만약 새로운 기능이 추가될 때마다 클래스를 수정해야 한다면 스프링 프레임워크에서 클래스를 제공할 수 없다.
	// 결국, 새로운 기능이 추가되더라도 DispatcherServlet 클래스의 소스는 변경할 필요가 없도록 개발되어야 한다.
	
	
	
	// 지금부터는 Spring MVC 구성을 알아보자
	1. 클라이언트로부터의 모든 '.do' 요청을 DispatcherServlet이 받는다.
	2. DispatcherServlet은 HandlerMapping을 통해 요청을 처리할 Controller를 검색한다.
	3. DispatcherServlet은 검색된 Controller를 실행하여 비즈니스 로직(클라이언트의 요청)을 처리한다.
	4. Controller는 비즈니스 로직의 수행 결과로 얻어낸 Model 정보와 Model을 보여줄 View 정보를 ModelAndView 객체에 저장하여 리턴한다.
	5. DispatcherServlet은 ModelAndView로부터 View 정보를 추출하고, ViewResolver를 이용하여 응답으로 사용할 View를 얻어낸다.
	6. DispatcherServlet은 ViewResolver를 통해 찾아낸 View를 실행하여 응답을 전송한다.
	
	
	
	// Spring MVC에서 가장 중요한 요소가 모든 클라이언트의 요청을 가장 먼저 받아들이는 DispatcherServlet이다.
	// WEB-INF/web.xml 파일에 스프링에서 제공하는 DispatcherServlet을 등록해준다.
	<servlet>
		<servlet-name>action</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	</servlet>
	
	<servlet-mapping>
		<servlet-name>action</servlet-name>
		<url-pattern>*.do</url-pattern>
	</servlet-mapping>
	

	// (위 설정에 따라)서블릿 컨테이너는 클라이언트의 '.do' 요청이 들어온 후에 DispatcherServlet 객체를 생성한다. 
	// DispatcherServlet 객체가 생성되고 나면 DispatcherServlet 클래스에 재정의된 init() 메소드가 자동으로 실행되고
	// XmlWebApplicationContext라는 스프링 컨테이너가 구동된다.
	// XmlWebApplicationContext는 ApplicationContext를 구현한 클래스이다.
	
	// Spring MVC 구성 요소 중에서 DispatcherServlet 클래스만이 유일한 서블릿이다.
	// 그런데 DispatcherServlet 객체 혼자서는 클라이언트의 요청을 처리할 수 없고, HandlerMapping, Controller, ViewResolver 객체들과 상호작용해야 한다.
	// 따라서 이 객체들을 메모리에 생성하기 위해 DispatcherServlet이 스프링 컨테이너를 구동하는 것이다.
	// 이 과정을 표현하면 SpringFramework Execution Process.png와 같다.
	
	// 서블릿 컨테이너가 DispatcherServlet 객체를 생성하고 나면 재정의된 init() 메소드가 자동으로 실행된다.
	// init() 메소드는 스프링 설정 파일([서블릿이름]-servlet.xml)을 로딩하여 XmlWebApplicationContext를 생성한다.( 스프링 컨테이너를 구동한다 )
	// 즉, 스프링 설정 파일([서블릿이름]-servlet.xml)에 DispatcherServlet이 사용할 HandlerMapping, Controller, ViewResolver 클래스를 <bean> 등록하면 된다.
	
	// 기본적으로 DispatcherServlet이 스프링 컨테이너를 구동할 때 /WEB-INF/[서블릿이름]-servlet.xml 파일을 찾아 로딩한다.
	// [서블릿이름]은 web.xml 파일에 등록된 서블릿 이름이다. 여기에 -servlet.xml을 붙여서 스프링 설정파일을 찾는다.
	
	// 만약 스프링 설정 파일의 이름이나 위치를 변경하려면 서블릿 초기화 파라미터를 이용한다.
	<servlet>
		<servlet-name>action</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
	    	<param-name>contextConfigLocation</param-name>
	    	<param-value>/WEB-INF/config/presentation-layer.xml</param-value>
	    </init-param>
	</servlet>
	
	
	// 스프링에서는 인코딩 처리를 위해 CharacterEncodingFilter 클래스를 제공하며, web.xml파일에 등록하면 모든 클라이언트의 요청에 대해 일괄적으로 인코딩을 처리할 수 있다.
	<filter>
		<filter-name>characterEncoding</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>utf-8</param-value>
		</init-param>
	</filter>
	
	<filter-mapping>
		<filter-name>characterEncoding</filter-name>
		<url-pattern>*.do</url-pattern>
	</filter-mapping>
	
	
	
	// 이제 스프링이 제공하는 Controller 인터페이스를 이용하여 컨트롤러를 만들어 보자.
	// 이전에 만든 컨트롤러에서 handleRequest() 메소드의 리턴 타입을 ModelAndView로 바꾼다.
	import org.springframework.web.servlet.mvc.Controller;
	public class LoginController implements Controller {
		@Override
		public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
			...
			ModelAndView mav = new ModelAndView();
			if (user != null) 
				mav.setViewName("getBoardList.do");
			else
				mav.setViewName("login.jsp");
				
			return mav;
		}
	}
	
	// 작성된 LoginController가 클라이언트의 "/login.do" 요청에 동작하게 만드려면 
	// presentation-layer.xml에 HandlerMapping과 LoginController를 <bean> 등록한다.
	// 여기서는 Properties 컬렉션을 사용하는 SimpleUrlHandlerMapping을 사용해본다.
	<!-- HandlerMapping 등록 -->
	<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
		<property name="mappings">
			<props>
				<prop key="/login.do">login(Controller bean id)</prop>
			</props>
		</property>
	</bean>
	
	<!-- Controller 등록 -->
	<bean id="login" class="com.springbook.view.user.LoginController"></bean>
	
	
	// 다른 컨트롤러도 한 번 만들어 보자
	public class getBoardListController implements Controller {
		@Override
		public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
			...
			ModelAndView mav = new ModelAndView();
			mav.addObject("boardList", boardList); // ModelAndView 객체에 저장하는 것 유의
			mav.setViewName("getBoardList.jsp");
			return mav;
		}
	}
	
	// DispatcherServlet은 Controller가 리턴한 ModelAndView 객체에서 Model 정보를 추출한 다음 HttpServletRequest 객체에
	// 검색 결과에 해당하는 Model 정보를 저장하여 JSP로 포워딩한다.
	// 따라서 JSP 파일에서는 검색 결과를 HttpServletRequest로부터 꺼내 쓸 수 있다.
	
	
	
	// 우리는 스프링 설정 파일인 presentation-lay.xml에 HandlerMapping, Controller 클래스를 <bean> 등록하여 스프링 컨테이너가 객체를 생성하도록 하였다.
	// 이제 ViewResolver를 적용해보자.
	// ViewResolver는 클라이언트로부터의 직접적인 jsp호출을 차단할 수 있어 거의 필수로 사용된다.
	// 여기서는 InternalResourceViewResolver를 사용해본다.
	
	// WEB-INF 폴더는 브라우저에서 접근이 불가능하다.
	// 하지만 InternalResourceViewResolver를 다음과 같이 설정하면 WEB-INF 폴더에 있는 jsp 파일을 view 화면으로 사용할 수 있다.
	// 결과적으로 직접적인 jsp 호출을 차단하게 된다.
	ex)
	<!-- ViewResolver 등록 -->
	<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/board/"></property>
		<property name="suffix" value=".jsp"></property>
	</bean>

	// WEB-INF/board/ 폴더에 getBoardList.jsp 파일을 놓는다고 가정해보자.	
	// ViewResolver를 적용할 때, ModelAndView 객체에 저장되는 View 이름은 ViewResolver 설정을 고려하여 등록해야 한다.
	// 따라서 앞에서 작성한 LoginController 클래스의 화면 내비게이션 코드를 다음처럼 수정한다.
	public class LoginController implements Controller {
		@Override
		public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
			...
			ModelAndView mav = new ModelAndView();
			if (user != null) 
				mav.setViewName("redirect:getBoardList.do");
			else
				mav.setViewName("redirect:login.jsp");
				
			return mav;
		}
	}
	
	// 위와 같이 설정하면 ViewResolver가 설정되어 있더라도 이를 무시하고 리다이렉트한다.
	// 즉, 'http://localhost:8080/myproject/WEB-INF/board/getBoardList.do.jsp'가 아닌 
	// 'http://localhost:8080/myproject/getBoardList.do'로 동작할 수 있게 해준다.
	// 그리고 로그인에 성공했을 때 실행되는 GetBoardListController에서는 확장자 '.jsp'를 제거해야 한다.
	public class getBoardListController implements Controller {
		@Override
		public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
			...
			ModelAndView mav = new ModelAndView();
			mav.addObject("boardList", boardList); // ModelAndView 객체에 저장하는 것 유의
			mav.setViewName("getBoardList");
			return mav;
		}
	}
	
	// 결국, InternalResourceViewResolver를 등록했을 때는 모든 View 이름에서 확장자 '.jsp'를 제거해야 한다.
	// 그리고 확장자가 '.do'인 요청은 앞에 'redirect:'를 붙여서 ViewResolver가 동작하지 않게 해야 한다.
	
------------------------------------------------------------------------------------------------------------------------------------

	// 스프링은 어노테이션 기반 설정을 제공하여 과도한 xml 설정으로 인한 문제를 해결한다.
	// Spring MVC도 어노테이션을 활용할 수 있다.
	
	// Spring MVC에서 어노테이션을 사용하려면 먼저 <beans> 루트 엘리먼트에 context 네임스페이스와 <context:component-scan> 엘리먼트를 추가한다.
	<beans xmlns="http://www.springframework.org/schema/beans"
	...
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
						http://www.springframework.org/schema/beans/spring-beans.xsd
						...
						http://www.springframework.org/schema/context
						http://www.springframework.org/schema/context/spring-context-4.2.xsd">
	
	<context:component-scan base-package="com.springbook.view"></context:component-scan>
	
	
	
	// 컨트롤러에는 @Controller 어노테이션을 붙인다.
	// @Component를 상속한 @Controller는 클래스의 객체를 메모리에 생성하고, DispatcherServlet이 인식하는 Controller 객체로 만들어 준다.
	// 만약 @Controller를 사용하지 않으면 위에서 작성했던 컨트롤러처럼 스프링에서 제공하는 Controller 인터페이스를 구현하고, handleRequest() 메소드를 재정의해야 한다.
	// 하지만 이렇게 구현한 Controller는 스프링 프레임워크가 지향하는 POJO가 아니다. 따라서 어노테이션으로 구현하는 게 좋을 것 같다.
	
	// 이제 클라이언트의 요청에 대해 Controller를 매핑할 수 있게 하자.
	// 스프링에서는 @RequestMapping을 이용하여 HandlerMapping을 대체한다.
	
	// 대부분 Controller는 사용자의 입력 정보를 추출하여 VO 객체에 저장한다.
	// 그리고 비즈니스 컴포넌트의 메소드를 호출할 때 VO 객체를 인자로 전달한다.
	// 사용자 입력 정보는 HttpServletRequest의 getParameter() 메소드를 사용하여 추출한다.
	// 그런데 사용자 입력 정보가 많으면 그만큼의 자바 코드가 필요해지고, 입력 정보가 변경될 때마다 Controller 클래스는 수정되어야 한다.
	
	// 하지만 Command 객체를 이용하면 이런 문제를 모두 해결할 수 있다.
	// Command 객체는 Controller 메소드 매개변수로 받은 VO 객체라고 보면 된다.
	
	@Controller
	public class InsertBoardController {
		@RequestMapping(value="/insertBoard.do") // @RequestMapping("/getBoardList.do") 로 작성 가능
		public String insertBoard(BoardVO vo) {
			BoardDAO boardDAO = new BoardDAO();
			boardDAO.insertBoard(vo);
		}
	}
	
	// insertBoard의 매개변수로 사용자가 입력한 값을 매핑할 BoardVO 클래스를 선언하면, 스프링 컨테이너가 Command 객체를 생성하여 넘겨준다.
	// 이때 사용자가 입력한 값들을 Command 객체에 세팅까지 해서 넘겨준다.
	// 중요한 것은 form 태그 안의 파라미터 이름과 Command 객체의 setter 메소드 이름(필드 이름)이 일치해야 한다.
	// 결과적으로 사용자 입력 정보 추출과 VO 객체 생성, 값 설정까지 모두 컨테이너가 자동으로 처리하는 것이다.
	
	
	// 잠시 서블릿 컨테이너와 기능을 정리해보자
	// 서블릿 객체는 서블릿 컨테이너가 생성한다. 그리고 service()(DispatcherServlet의 메소드), doGet(), doPost() 메소드도 서블릿 컨테이너가 호출한다.
	// 이 때  service(), doGet(), doPost() 메소드가 정상적으로 호출되려면 HttpServletRequest, HttpServletResponse 객체가 필요한데
	// 이 객체들도 서블릿 컨테이너가 생성해서 넘겨준다.
	// 결국 service() 메소드는 매개변수로 받은 HttpServletRequest 객체를 통해 다양한 요청 처리를 구현할 수 있다.
	
	// 스프링 컨테이너, 어노테이션의 기능을 정리해보자
	// 클라이언트가 글 등록 정보를 입력하고, 서버에 "insertBoard.do" 요청을 전달하면 스프링 컨테이너는 @Controller가 붙은 모든 컨트롤러 객체를 생성하고,
	// InsertBoardController가 가지고 있는 insertBoard() 메소드를 실행한다.
	// 이때 매개변수에 해당하는 BoardVO 객체를 스프링 컨테이너가 생성하여 전달한다.
	
	
	
	// InsertBoardController를 완성해보자
	// DB 연동 처리를 위해 BoardDAO도 매개변수로 선언했다.
	// DAO 객체 역시 Command 객체처럼 스프링 컨테이너가 해당 객체를 생성하여 전달해준다.
	@Controller
	public class InsertBoardController {
		@RequestMapping(value="/insertBoard.do") // @RequestMapping("/getBoardList.do") 로 작성 가능
		public String insertBoard(BoardVO vo, BoardDAO boardDAO) {
			boardDAO.insertBoard(vo);
			return "getBoardList.do"; // 포워딩이 아니라 리다이렉트를 원할 때는 "redirect:" 라는 접두사를 붙이면 된다.
		}
	}
	
	// getBoardListController를 완성해보자
	// 검색 결과와 화면 정보를 저장하여 리턴하기 위한 ModelAndView를 매개변수로 선언하여 컨테이너가 생성하도록 처리했다.
	@Controller
	public class getBoardListController {
		@RequestMapping("/getBoardList.do")
		public ModelAndView handleRequest(BoardVO vo, BoardDAO boardDAO, ModelAndView mav) {
			mav.addObject("boardList", boardDAO.getBoardList(vo)); 
			mav.setViewName("getBoardList.jsp");
			return mav;
		}
	}
	
	
	
	// Controller를 하나의 클래스로 묶어서 처리하면 관리가 더 편할 것이다.
	@Controller
	public class BoardController {
	
		@RequestMapping("/insertBoard.do") 
		public String insertBoard(BoardVO vo, BoardDAO boardDAO) {
			boardDAO.insertBoard(vo);
			return "getBoardList.do"; 
		}
	
		@RequestMapping("/getBoardList.do")
		public ModelAndView getBoardList(BoardVO vo, BoardDAO boardDAO, ModelAndView mav) {
			mav.addObject("boardList", boardDAO.getBoardList(vo)); 
			mav.setViewName("getBoardList.jsp");
			return mav;
		}
	
		...
	}
	
	
	
	// @Requestmapping을 이용하면 마치 Servlet처럼 클라이언트의 요청 방식(get/post)에 따라 수행될 메소드를 다르게 설정할 수 있다.
	@Controller
	public class LoginController {
		@RequestMapping(value="/login.do", method=RequestMethod.GET)
		public String loginView(UserVO vo) { 
			return "login.jsp";
		}
		
		@RequestMapping(value="/login.do", method=RequestMethod.POST)
		public String login(UserVO vo, UserDAO userDAO) {
			if (userDAO.getUser(vo) != null) 
				return "getBoardList.do";
			else
				return "login.jsp";
		}
	}
	
	// 참고로 클라이언트가 직접 url을 입력하거나 하이퍼링크를 클릭하여 요청하면 기본이 get 방식이다.
	
	// loginView() 메소드에서는 사용자가 입력할 값이 아무것도 없는 상태인데 매개변수로 UserVO 객체를 받아들이도록 되어있다.
	// 하지만 이렇게 매개변수로 받은 Command 객체에 적절한 데이터를 설정하면, 리턴된 jsp 파일에서 이 데이터를 사용 가능하다.
	<form action="login.do" method="post">
	<table border="1" cellpadding="0" cellspacing="0">
		<tr>
			<td bgcolor="orange">아이디</td>
			<td><input type="text" name="id" value="${userVO.id}"/></td>
		</tr>
		
		<tr>
			<td bgcolor="orange">비밀번호</td>
			<td><input type="password" name="password" value="${userVO.password}"/></td>
		</tr>
		
		<tr>
			<td colspan="2" align="center">
				<input type="submit" name="로그인"/>
			</td>
		</tr>
	</table>
	</form>
	
	// 스프링 컨테이너가 생성하는 Command 객체의 이름은 클래스 이름의 첫 글자를 소문자로 변경한 이름이 자동으로 설정된다.
	// 그래서 위의 html 구문에서 UserVO 객체 변수에 접근할 때 ${userVO.변수명} 형태를 사용하였다.
	// 만약 Command 객체의 이름을 변경하려면 아래와 같이 @ModelAttribute를 사용해야 한다.
	@RequestMapping(value="/login.do", method=RequestMethod.GET)
	public String loginView(@ModelAttribute("user") UserVO vo) { 
		return "login.jsp";
	}
	
	<tr>
		<td bgcolor="orange">아이디</td>
		<td><input type="text" name="id" value="${user.id}"/></td>
	</tr>
	
	
	
	// 지금까지 Controller 메소드에서 사용자가 입력한 정보를 추출하기 위해 HttpServletRequest 대신 Command 객체를 사용했다.
	// 만약 HttpServletRequest 객체가 제공하는 다양한 메소드를 이용하여 Controller를 구현해야 할 때는 HttpServletRequest 객체를 매개변수로 받아야 한다.
	// 스프링 MVC에서는 Controller 메소드 매개변수로 다양한 Servlet API를 사용할 수 있도록 지원한다.
	ex) HttpSession
	@RequestMapping(value="/login.do", method=RequestMethod.POST)
	public String login(UserVO vo, UserDAO userDAO, HttpSession session) {
		UserVO user = userDAO.getUser(vo);
		if (user != null) {
			session.setAttribute("username", user.getName()); // getBoardList.jsp에서 ${username}으로 사용 가능
			return "getBoardList.do";
		}
		else
			return "login.jsp";
	}
	
	
	
	// Controller에 메소드를 정의할 때 리턴타입을 하나로 통일하는 게 좋고, 보통 String으로 통일한다.
	// BoardController의 getBoardList() 메소드의 리턴 타입을 String으로 수정해보자
	@RequestMapping("/getBoardList.do")
	public String getBoardList(BoardVO vo, BoardDAO boardDAO, Model model) {
		model.addAttribute("boardList", boardDAO.getBoardList(vo));
		return "getBoardList.jsp";
	}
	
	// ModelAndView 객체를 더 이상 사용하지 않기 때문에 매개변수를 Model로 변경하면 된다.
	// Model에 저장된 데이터는 리턴된 jsp 화면에서 사용할 수 있다.
	// 리턴 값으로 문자열을 반환하고 있는데 이렇게 view 이름이 문자열로 리턴되면 스프링 컨테이너가 리턴된 jsp 파일을 찾아 실행한다.
	
	
	
	// Command 객체를 이용하면 클라이언트에서 넘겨준 요청 파라미터 정보를 받아낼 수 있다.
	// 만약 Command 객체에 없는 파라미터를 Controller 클래스에서 사용하려면 @RequestParam을 이용한다.
	@RequestMapping("/getBoardList.do")
	public String getBoardList(@RequestParam(value="searchCondition", defaultValue="title", required=false) String condition,
							   BoardVO vo, BoardDAO boardDAO, Model model) {
		model.addAttribute("boardList", boardDAO.getBoardList(vo));
		return "getBoardList.jsp";
	}
	
	// @RequestParam에서 사용된 속성의 의미는 다음과 같다.
	value : 화면으로부터 전달될 파라미터 이름
	defaultValue : 화면으로부터 전달될 파라미터 정보가 없을 때, 설정할 기본값
	required : 파라미터 생략 여부
	// 결국 위 설정은 searchCondition이 필수 파라미터는 아니지만 만약 파라미터 정보가 전달되면 해당 값을 추출하여 condition 변수에 할당하고
	// 파라미터 정보가 전달되지 않았다면 기본값으로 "title"을 할당하라는 의미이다.
	// 물론 @RequestParam을 사용하기 싫으면 Command 객체에 해당 필드와 세터메소드를 추가해주면 된다.
	
	
	
	// 앞에서 @ModelAttribute를 Controller 메소드의 매개변수로 선언된 Command 객체의 이름을 변경할 때 사용했다.
	// 추가로 View(jsp)에서 사용할 데이터를 설정하는 용도로도 사용할 수 있다.
	// @ModelAttribute가 설정된 메소드는 @RequestMapping 어노테이션이 적용된 메소드보다 먼저 호출된다.
	// 그리고 @ModelAttribute 메소드 실행 결과로 리턴된 객체는 자동으로 Model에 저장된다.
	// 따라서 @ModelAttribute 메소드의 실행 결과로 리턴된 객체를 View 페이지에서 사용할 수 있다.
	@Controller
	public class BoardController {
	
		@ModelAttribute("conditionMap")	// "conditionMap"이라는 이름으로 리턴값을 Model 객체에 저장한다.
		public Map<String, String> searchConditionMap() {
			Map<String, String> conditionMaps = new HashMap<>();
			conditionMaps.put("제목", "TITLE");
			conditionMaps.put("내용", "CONTENT");
			return conditionMaps;
		}
		...
		@RequestMapping("/getBoardList.do")
		public String getBoardList(BoardVO vo, BoardDAO boardDAO, Model model) {
			model.addAttribute("boardList", boardDAO.getBoardList(vo));
			return "getBoardList.jsp";
		}
	}
	
	<form action="getBoardList.do" method="post">
	<table border="1" cellpadding="0" cellspacing="0" width="700">
	<tr>
		<td align="right">
			<select name="searchCondition">
			<c:forEach items="${conditionMap}" var="option">
				<option value="${option.value}">${option.key}
			</c:forEach>
			</select>
			<input name="searchKeyword" type="text"/>
			<input type="submit" value="검색"/>	
		</td>
	</tr>
	</table>
	</form>
	
	
	
	// @SessionAttributes는 수정 작업을 처리할 때, 유용하게 사용할 수 있다.
	// 예를 들어, 입력 <form>이 특정 정보만 전달하는 경우 Command 객체의 특정 필드에는 값이 들어있지 않을 것이다.
	// 그런데 이 Command 객체의 모든 필드 값을 이용해서 쿼리를 작성한다고 하면 쿼리의 ? 부분에 null 값이 들어가는 경우가 생긴다.
	// @SessionAttributes를 이용하면 이를 방지할 수 있다.
	ex)
	@Controller
	@SessionAttributes("board")
	public class BoardController {
		...
		@RequestMapping("/updateBoard.do")
		public String updateBoard(@ModelAttribute("board") BoardVO vo, BoardDAO boardDAO) {
			boardDAO.updateBoard(vo);
			return "getBoardList.do";
		}
		
		@RequestMapping("/getBoard.do")
		public String getBoard(BoardVO vo, BoardDAO boardDAO, Model model) {
			model.addAttribute("board", boardDAO.getBoard(vo));
			return "getBoard.jsp";
		}
	}
	
	// 우선 게시판 글을 보기 위해 "/getBoard.do" 요청을 하면 getBoard() 메소드가 실행된다.
	// getBoard() 메소드에서는 게시글 검색 결과를 "board"라는 이름으로  Model에  저장하고 있다.
	// 이떄 BoardController 클래스에 선언된 @SessionAttributes("board") 어노테이션 기능이 작동하는데
	// Model에 "board"라는 이름으로 저장되는 데이터가 있다면 그 데이터를 세션(HttpSession)에도 자동으로 저장하라는 설정이다.
	
	// updateBoard() 메소드가 호출될 때, 스프링 컨테이너는 우선 @ModelAttribute("board") 설정을 해석하여 세션에 board라는 이름으로 저장된 데이터가 있는지 확인한다.
	// 있다면 해당 객체를 세션에서 꺼내서 매개변수로 선언된 vo 변수에 할당한다.
	// 이때 사용자가 입력한 수정 정보 값만 새롭게 할당되고, 나머지는 세션에 저장된 데이터가 유지된다.
	
	
	
	// 지금까지 Spring MVC를 기반으로 개발한 게시판 프로그램의 구조와 실행 순서를 다시 한 번 확인해보자.
	1. 브라우저에서 버튼이나 하이퍼링크를 클릭하여 서버에 요청을 전송하면, 모든 요청을 서블릿 컨테이너가 생성한 DispatcherServlet이 받는다.
	2. DispatcherServlet은 스프링 컨테이너가 생성한 Controller에게 요청을 전달한다.
	3. Controller는 매개변수를 통해 전달된 DAO 객체를 이용하여 사용자가 요청한 로직을 처리한다.
	
	// Controller는 DAO 객체를 직접 이용하지 않고, 비즈니스 컴포넌트(XXXServiceImpl)를 이용하여 작업을 처리하는 것이 일반적이다.
	// Controller 메소드에서  DAO의 메소드를 호출하면 안 되는 첫 번째 이유는 유지보수 과정에서 다른 DAO 클래스를 다른 클래스로 쉽게 교체하기 위해서다.
	// 비즈니스 컴포넌트 입장에서 자신을 사용하는 클라이언트는 Controller이다.
	// Controller가 인터페이스를 통해서 비즈니스 컴포넌트를 이용하면 컴포넌트의 구현 클래스를 수정하거나 다른 클래스로 대체해도 이를 사용하는 Controller는 수정하지 않아도 된다.
	@Controller
	@SessionAttributes("board")
	public class BoardController {
		@Autowired
		private BoardService boardService;
		
		@RequestMapping("/insertBoard.do")
		public String insertBoard(BoardVO vo) {
			boardService.insertBoard(vo);
			return "getBoardList.do";
		}
		
		@RequestMapping("/updateBoard.do")
		public String updateBoard(@ModelAttribute("board") BoardVO vo) {
			boardService.updateBoard(vo);
			return "getBoardList.do";
		}
		
		@RequestMapping("/getBoard.do")
		public String getBoard(BoardVO vo, Model model) {
			model.addAttribute("board", boardService.getBoard(vo));
			return "getBoard.jsp";
		}
		...
		@ModelAttribute("conditionMap")	
		public Map<String, String> searchConditionMap() {
			Map<String, String> conditionMaps = new HashMap<>();
			conditionMaps.put("제목", "TITLE");
			conditionMaps.put("내용", "CONTENT");
			return conditionMaps;
		}
	}
	
	// 이제 BoardServiceImpl 클래스의 멤버변수로 선언된 BoardDAO를 다른 DAO 클래스로 변경해도 Controller는 수정할 필요가 없다.
	
	// Controller에서 DAO의 메소드를 호출하면 안 되는 두 번째 이유는 AOP 적용 때문이다.
	// 횡단 관심에 해당하는 어드바이스가 동작하려면 Service 구현 클래스의 비즈니스 메소드가 실행되어야 한다.( 포인트컷을 설정할 때 Service 구현 클래스의 메소드에 설정했다 )
	// 그렇다면 Controller보다 의존성 주입될 XXXServiceImpl 객체가 먼저 생성되어 있어야 한다.
	// 결국 Controller보다 의존성 주입 대상이 될 비즈니스 컴포넌트를 먼저 생성하려면 비즈니스 컴포넌트를 먼저 생성하는 스프링 컨테이너가 필요하다.
	// 그리고 이 컨테이너를 Controller를 메모리에 생성하는 컨테이너보다 먼저 구동하면 된다.
	// 이때 사용하는 클래스가 스프링에서 제공하는 ContextLoadListener이다.
	
	// Listener는 Servlet이나 Filter 클래스처럼 web.xml에 등록한다.
	// ContextLoadListener 클래스는 서블릿 컨테이너가 web.xml 파일을 읽어서 구동될 때, 자동으로 메모리에 생성된다.
	// 즉, 클라이언트의 요청이 없어도 컨테이너가 구동될 때 Pre-Loading되는 객체다.( DispatcherServlet은 클라이언트의 최초 요청이 있어야 생성됨 )
	// ContextLoadListener는 기본적으로 /WEB-INF/applicationContext.xml 파일을 읽는다.
	// 따라서 <context-param> 태그를 이용해 /src/main/resources 소스 폴더에 있는 applicationContext.xml 파일을 읽게 해준다.
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:applicationContext.xml</param-value>
	</context-param>
	<listener>
		<listener-class>
			org.springframework.web.context.ContextLoaderListener
		</listener-class>
	</listener>
	
	
	
	// 이제 정리를 해보자.
	1. 톰캣 서버를 처음 구동하면 web.xml 파일을 로딩하여 서블릿 컨테이너가 구동된다.
	2. 서블릿 컨테이너는 web.xml 파일에 등록된 ContextLoadListener 객체를 생성(Pre-Loading)한다.
	3. ContextLoadListener 객체는 /src/main/resources 폴더에 있는 applicationContext.xml 파일을 로딩하여 스프링 컨테이너(ROOT컨테이너)를 구동한다.
	4. Service 구현 클래스 혹은 DAO 클래스 객체들이 메모리에 생성된다.
	5. 사용자가 .do 요청을 서버에 전달하면 서블릿 컨테이너가 DispatcherServlet 객체를 생성한다.
	6. DispatcherServlet 객체는  /WEB-INF/config 폴더에 있는 presentation-layer.xml 파일을 로딩하여 두 번째 스프링 컨테이너를 구동한다.
	7. 두 번째 스프링 컨테이너가 Controller 객체를 메모리에 생성한다.
	- 결과적으로 ContextLoadListener가 생성한 ROOT 컨테이너(부모)의 비즈니스 객체를 DispatcherServlet이 생성한 스프링 컨테이너(자식)의 Controller가 사용한다.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

</beans>