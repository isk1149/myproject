<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:c="http://www.springframework.org/schema/c"
	xmlns:cache="http://www.springframework.org/schema/cache"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jdbc="http://www.springframework.org/schema/jdbc"
	xmlns:jee="http://www.springframework.org/schema/jee"
	xmlns:lang="http://www.springframework.org/schema/lang"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:task="http://www.springframework.org/schema/task"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
		http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-4.2.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd
		http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.2.xsd
		http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.2.xsd
		http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-4.2.xsd
		http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd
		http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.2.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd">

------------------------------------------------------------------------------------------------------------------------------------

	// 스프링 설정 파일 이름은 무엇이든 상관 없지만 <beans>를 루트 엘리먼트로 사용해야 한다.
	
	

	// <import>엘리먼트는  트랜잭션 관리, 예외 처리, 다국어 처리 등 여러 설정을 할 때 기능별로 xml 파일을 나누는데 이렇게 분리한 설정 파일을 하나로 통합할 때 사용한다.
	<import resource="context-datasource.xml"/>
	<import resource="context-transaction.xml"/>
	
	
	
	// 스프링 설정 파일에 클래스를 등록하려면 <bean> 엘리먼트를 사용한다. 
	<bean id="test" class="com.myproject.webapp.test.Test" init-method="initMethod" destroy-method="destroyMethod" lazy-init="true"
		  scope(설정 안하면 singletonrk default)="singleton or prototype"></bean>
	
	
	
	// 스프링 프레임워크의 가장 중요한 특징은 객체의 생성과 의존관계를 컨테이너가 자동으로 관리한다는 것이다. 이것이 스프링 IoC(제어의 역전)의 핵심이다.
	// 의존성 주입은 컨테이너가 스프링 설정 파일에 등록된 정보를 바탕으로 직접 객체들 사이의 의존관계를 처리하는 것을 의미한다. 생성자 인젝션과 세터 인젝션이 있다. 
	// 생성자 인젝션
	// 스프링 컨테이너는 xml 설정 파일에 등록된 클래스를 찾아서 객체를 생성할 때 기본적으로 매개변수가 없는 기본 생성자를 호출한다.
	// 매개변수를 가지는 생성자를 호출하려면 생성자 인젝션을 사용한다.
	// 아래 예시의 경우 SonySpeaker가 먼저 생성된 후 SamsungTV가 생성된다.
	<bean id="tv" class="polymorphism.SamsungTV">
		<constructor-arg ref="sony"></constructor-arg>
		<constructor-arg value="27000"></constructor-arg>
		
		// 생성자 오버로딩이 되어있다면 헷갈릴 수 있기 때문에 인덱스도 사용 가능하다
		<constructor-arg index="0" ref="sony"></constructor-arg>
		<constructor-arg index="1" value="27000"></constructor-arg>
	</bean>
	<bean id="sony" class="polymorphism.SonySpeaker"></bean>
	
	
	
	// 세터 인젝션
	// 코딩 컨벤션에 따라 보통 세터 인젝션을 사용한다.( 세터 메소드가 제공되지 않는 클래스에 대해서만 생성자 인젝션 사용 )
	// 세터 메소드가 있어야 하고, bean 객체 생성 후에 세터 인젝션이 적용되므로 기본 생성자도 있어야 함
	// name의 첫 글자를 대문자로 바꾸고 앞에 set을 붙인 메소드가 실행된다.
	<bean id="tv" class="polymorphism.SamsungTV">
		<property name="speaker" ref="sony"></property>  -> setSpeaker() 호출
		<property name="price" value="27000"></property>
	</bean>
	<bean id="sony" class="polymorphism.SonySpeaker"></bean>
	
	
	
	// 세터 인젝션을 설정할 때  p네임스페이스를 이용할 수 있다.
	// p네임스페이스는 별도의 schemaLocation이 없기 때문에 네임스페이스만 선언하면 된다.
	<beans xmlns="http://www.springframework.org/schema/beans"
		   ...
		   xmlns:p="http://www.springframework.org/schema/p"
		   ...
		   xsi:schemaLocation="http://www.spring...">
	
	// p네임스페이스를 선언하면 다음과 같이 세터 인젝션이 가능하다
	<bean id="tv" class="polymorphism.SamsungTV" p:speaker-ref="sony" p:price="27000"></bean>
	<bean id="sony" class="polymorphism.SonySpeaker"></bean>
	
	
	
	// 배열, 컬렉션 객체 설정
	// 배열, java.util.List 타입 객체 세터 인젝션( private List<String> addressList; 라고 가정)
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<list>
				<value>서울시 강남구 역삼동</value>
				<value>서울시 성동구 행당동</value>
			</list>
		</property>
	</bean>
	
	// java.util.Set 타입 객체 세터 인젝션( private Set<String> addressList; 라고 가정)
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<set value-type="java.lang.String">
				<value>서울시 강남구 역삼동</value>
				<value>서울시 성동구 행당동</value>
				<value>서울시 성동구 행당동</value> -> Set이라 저장 안 됨
			</set>
		</property>
	</bean>
	
	// java.util.Map 타입 객체 세터 인젝션( private Map<String, Controller> addressList; 라고 가정)
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<map>
				<entry>
					<key><value>고길동</value></key>
					<value>서울시 강남구 역삼동</value>
				</entry>
				<entry>
					<key><value>마이콜</value></key>
					<value>서울시 성동구 성수동</value>
				</entry>
			</map>
		</property>
	</bean>
	
	// java.util.Properties 타입 객체 세터 인젝션( private Properties addressList; 라고 가정)
	// Properties는  key=value 형태의 데이터
	<bean id="test" class="com.myproject.webapp.test.Test">
		<property name="addressList">
			<props>
				<prop key="고길동">서울시 강남구 역삼동</prop>
				<prop key="마이콜">서울시 성동구 성수동</prop>
			</props>
		</property>
	</bean>
	
	
	
	// 어노테이션 설정을 위한 context 네임스페이스 및 스키마 문서 위치 등록, 컴포넌트 스캔 설정
	<beans xmlns="http://www.springframework.org/schema/beans"
		   ...
		   xmlns:context="http://www.springframework.org/schema/context"
		   ...
		   xsi:schemaLocation="http://www.spring...
		   					   http://www.springframework.org/schema/context 
		   					   http://www.springframework.org/schema/context/spring-context-4.2.xsd">
	
	// com.myproject.webapp 패키지 및 그 이하의 패키지 전부 적용 
	<context:component-scan base-package="com.myproject.webapp"></context:component-scan>
	
	// 컴포넌트 스캔 설정을 하면  클래스 위에  @Component 어노테이션을 설정하면 스프링 컨테이너가 객체를 생성해준다. 당연히 기본 생성자가 있어야 한다.
	// id를 설정하려면  @Component("tv")와 같이 설정해주면 되고, 지정하지 않으면 컨테이너가 자동으로 이름을 설정한다.( 이름 규칙은 클래스 이름의 첫 글자를 소문자로 변경한 것이다. )
	
	// 의존성 주입을 지원하는 어노테이션은 [@Autowired, @Qualifier](스프링에서 제공), @Inject, @Resource가 있다.
	
	// @Autowired는 생성자, 메소드, 멤버변수 위에 모두 사용 가능하지만 보통 멤버변수 위에 선언한다.
	// 스프링 컨테이너는 멤버 변수 위에 붙은 @Autowired를 확인한 후 해당 변수의 타입을 체크하여 해당 타입 객체가 메모리에 존재하는지 확인 후 변수에 주입한다.
	// 해당 객체가 메모리에 없다면 NoSuchBeanDefinitionException을 발생시킨다.
	// 문제는 인터페이스 변수 위에 @Autowired가 있고, 메모리에 구현 클래스 객체가 여러 개 있을 때 발생한다.
	// 이런 문제를 해결하기 위해 @Autowired와 @Qualifier("sony")를 같이 설정해준다.
	// 참고로 어노테이션으로 주입하는 경우 세터메소드가 필요 없다.
	@Component("tv")
	public class LgTV implements TV {
		@Autowired
		@Qualifier("sony")
		private Speaker speaker;
		
		public LgTV() { }
	}
	
	// @Resource는 객체의 이름을 이용하여 의존성 주입을 처리한다. @Inject도 이름 기반의 의존성 주입을 한다.
	@Component("tv")
	public class LgTV implements TV {
		@Resource(name="sony")
		private Speaker speaker;
		
		public LgTV() { }
	}
	
	
	
	// <bean> 엘리먼트 등록과 어노테이션을 적절히 사용해주면 좋다.
	// 변경되지 않는 객체는 어노테이션으로 설정하고, 변경될 가능성이 있는 객체는  <bean> 엘리먼트로 설정한다.
	// 참고로 라이브러리 형태로 제공되는 클래스는 xml 설정만 가능한다.
	
	
	
	// Presentation_And_Business_Layer.png 파일 확인
	// 프레젠테이션 레이어는 사용자와의 커뮤니케이션을 담당하고, 비즈니스 레이어는 사용자의 요청에 대한 비즈니스 로직 처리를 담당한다.
	// 이 구조에서 핵심은 Controller, ServiceImpl, DAO 클래스이다.
	// Controller : 사용자 요청 제어,  ServiceImpl: 비즈니스 로직 처리,   DAO : DB연동
	// 스프링 프레임워크에서는 이런 클래스들을 구분하기 위해  @Component를 상속한 3개의 어노테이션을 추가로 제공하고 각각 특별한 기능을 가지고 있다.
	-------------------------------------------------------------------------
	|	어노테이션		|		위치			|				의미					|
	-------------------------------------------------------------------------
	| @Service		| XXXServiceImpl	| 비즈니스 로직을 처리하는 Service 클래스		|
	-------------------------------------------------------------------------
	| @Repository	| XXXDAO			| DB연동을 처리하는 DAO 클래스				|
	-------------------------------------------------------------------------
	| @Controller	| XXXController		| 사용자 요청을 제어하는 Controller 클래스		|
	-------------------------------------------------------------------------
	
	
	
	// VO 클래스는 레이어와 레이어 사이에서 관련된 데이터를 한 번에 주고받을 목적으로 사용한다.
	// 하나의 테이블마다 하나의 VO 클래스가 있고, 테이블이름 뒤에 VO 붙인다.
	// 필드도 컬럼 이름과 타입에 맞게 private로 설정하고 게터/세터 메소드를 만들어주면 된다.
	
	
	
	// DAO 클래스는 DB 연동을 담당한다. CRUD 기능의 메소드를 구현하면 된다. @Repository("XXXDAO") 어노테이션을 지정해준다.
	// CRUD 기능 메소드 이름은 기능+테이블명으로 지정한다.( insert, update, delete, get, getXXXList 등 )
	
	
	
	// DB 연동을 위해 JDBC 드라이버가 필요하다.
	// oracle, mysql 관련 설정 찾아보기
	
	
	 
	// 서비스 인터페이스는 DAO 클래스에서  Alt+Shift+T를 눌러 쉽게 생성할 수 있다.
	// 서비스 인터페이스를 구현한 서비스 XXXServiceImpl 클래스를 구현해준다.
	// @Service("XXXService") 어노테이션을 지정해주고, 필드의  private XXXDAO xxxDAO; 를 @Autowired 어노테이션으로 지정해준다.

------------------------------------------------------------------------------------------------------------------------------------
	
	// 비즈니스 컴포넌트 개발에서 중요한 두 가지는 낮은 결합도와 높은 응집도를 유지하는 것이다.
	// 스프링의 의존성 주입을 이용하면 비즈니스 컴포넌트를 구성하는 객체들의 결합도를 낮출 수 있다.
	// AOP는 응집도를 높일 수 있다.
	
	// AOP를 이해하는 데 가장 핵심 개념은 관심 분리이다.
	// AOP에서는 메소드마다 공통으로 등장하는 로깅이나 예외, 트랜잭션 처리 같은 코드들을 횡단 관심이라고 한다.
	// 이에 반해 사용자의 요청에 따라 실제로 수행되는 핵심 비즈니스 로직을 핵심 관심이라고 한다.
	
	
	
	// AOP를 적용하기 위해서 우선 pom.xml을 수정하여 AOP관련 라이브러리를 추가한다.
	<dependency>
		<groupId>org.aspectj</groupId>
		<artifactId>aspectjweaver</artifactId>
		<version>1.8.8</version>
	</dependency>
	
	// 스프링 설정 파일(applicationContext.xml)에서 aop 네임스페이스를 추가한다.
	<beans xmlns="http://www.springframework.org/schema/beans"
		   ...
		   xmlns:aop="http://www.springframework.org/schema/aop"
		   ...
		   xsi:schemaLocation="http://www.spring...
		   					   http://www.springframework.org/schema/aop 
		   					   http://www.springframework.org/schema/aop/spring-aop-4.2.xsd">
	
	// 이제 aop 관련 설정을 작성한다.
	// 아래 설정은 allPointcut으로 설정한 포인트컷 메소드가 호출되면 log라는 어드바이스 객체의 printLog 메소드가 실행되고 이때 printLog의 동작 시점은 before라는 뜻이다.
	<bean id="log" class="com.springbook.biz.comm.LogAdvice"></bean>
	<aop:config>
		<aop:pointcut id="allPointcut" expression="execution( * com.springbook.biz..*Impl.*(..) )"/>
		<aop:aspect ref="log">
			<aop:before pointcut-ref="allPointcut" method="printLog"/>
		</aop:aspect>
	</aop:config>
	
	
	
	// 조인포인트 : 클라이언트가 호출하는 모든 비즈니스 메소드. XXXServiceImpl 클래스의 모든 메소드가 조인포인트라고 생각하면 된다.
	// 포인트컷 : 횡단 관심을 적용시킬 필터링된 조인포인트이다. 핵심 관심이라고 보면 된다.
	// 어드바이스 : 횡단 관심에 해당하는 공통 기능의 코드이다. 어드바이스 동작 시점은  before, after-returning, after-throwing, after, around가 있다.
	// 위빙 : 포인트컷으로 지정한 핵심 관심 메소드가 호출될 때, 어드바이스에 해당하는 횡단 관심 메소드가 삽입되는 과정을 의미한다.
	
	// AOP(Aspect Oriented Programming)이라는 이름에서 알 수 있듯이 AOP의 핵심은 애스팩트이다.
	// 애스팩트는 포인트컷과 어드바이스의 결합이다. 어떤 포인트컷 메소드에 대해 어떤 어드바이스 메소드를 실행할지 결정한다. 
	
	
	
	// AOP 설정에서 <aop:config>는 루트 엘리먼트이다. 스프링 설정 파일 내에 여러번 사용할 수 있고, 하위에는 <aop:pointcut>, <aop:aspect>가 위치할 수 있다. 
	// <aop:pointcut> 엘리먼트는 포인트컷을 지정할 때 사용한다. 만약 <aop:aspect> 하위에 설정되면 해당 <aop:aspect>에서만 사용 가능하다.
	// 애스팩트는 <aop:aspect> 엘리먼트로 설정하며, 핵심 관심에 해당하는 포인트컷 메소드와 횡단 관심에 해당하는 어드바이스 메소드를 결합하기 위해 사용한다. 
	// 만약 어드바이스 객체의 아이디를 모르거나 메소드 이름을 확인할 수 없을 경우 애스팩트를 설정할 수 없다. 이런 경우 <aop:advisor> 엘리먼트를 사용한다.
	
	
	
	// 포인트컷 표현식
	// execution( * com.springbook.biz..*Impl.*(..) )
	
	// 리턴타입 지정
	-------------------------------------------------------------------------
	|	표현식	|				설명											|
	-------------------------------------------------------------------------
	| *			| 모든 리턴타입 허용												|
	-------------------------------------------------------------------------
	| void		| 리턴타입이 void인 메소드 선택										|
	-------------------------------------------------------------------------
	| !void		| 리턴 타입이 void가 아닌 메소드 선택									|
	-------------------------------------------------------------------------	
	
	// 패키지 지정
	-------------------------------------------------------------------------------------------------
	|	표현식						|				설명												|
	-------------------------------------------------------------------------------------------------
	| com.springbook.biz			| 정확하게 com.springbook.biz 패키지만 선택								|
	-------------------------------------------------------------------------------------------------
	| com.springbook.biz..			| com.springbook.biz 패키지로 시작하는 모든 패키지 선택						|
	-------------------------------------------------------------------------------------------------
	| com.springbook..impl			| com.springbook 패키지로 시작하면서 마지막 패키지 이름이 impl로 끝나는 패키지 선택	|
	-------------------------------------------------------------------------------------------------
	
	// 클래스 지정
	-----------------------------------------------------------------------------
	|	표현식			|				설명										|
	-----------------------------------------------------------------------------
	| BoardServiceImpl	| 정확하게 BoardServiceImpl 클래스만 선택						|
	-----------------------------------------------------------------------------
	| *Impl				| 클래스 이름이 Impl로 끝나는 클래스만 선택							|
	-----------------------------------------------------------------------------
	| BoardService+		| 클래스 이름 뒤에 '+'가 붙으면 해당 클래스로부터 파생된 모든 자식 클래스 선택. 	|
	|					| 인터페이스 뒤에 '+'가 붙으면 해당 인터페이스를 구현한 모든 클래스 선택			|
	-----------------------------------------------------------------------------
	
	// 메소드 지정
	-------------------------------------------------------------------------
	|	표현식	|				설명											|
	-------------------------------------------------------------------------
	| *(..)		| 가장 기본 설정으로 모든 메소드 선택									|
	-------------------------------------------------------------------------
	| get*(..)	| 메소드 이름이 get으로 시작하는 모든 메소드 선택							|
	-------------------------------------------------------------------------

	// 매개변수 지정
	-------------------------------------------------------------------------------------------------
	|	표현식						|				설명												|
	-------------------------------------------------------------------------------------------------
	| (..)							| 가장 기본 설정으로 '..'은 매개변수의 개수와 타입에 제약이 없음을 의미					|
	-------------------------------------------------------------------------------------------------
	| (*)							| 반드시 1개의 매개변수를 가지는 메소드만 선택									|
	-------------------------------------------------------------------------------------------------
	| (com.springbook.user.UserVO)	| 매개변수로 UserVO를 가지는 메소드만 선택. 패키지 경로가 포함되어야 함				|
	-------------------------------------------------------------------------------------------------
	| (!com.springbook.user.UserVO)	| 매개변수로 UserVO를 가지지 않는 메소드만 선택								|
	-------------------------------------------------------------------------------------------------
	| (Integer, ..)					| 한 개 이상의 매개변수를 가지되, 첫 번째 매개변수의 타입이 Integer인 메소드만 선택		|
	-------------------------------------------------------------------------------------------------
	| (Integer, *)					| 반드시 두 개의 매개변수를 가지되, 첫 번째 매개변수의 타입이 Integer인 메소드만 선택		|
	-------------------------------------------------------------------------------------------------
	
	
	
	// 어드바이스 동작 시점
	-------------------------------------------------------------------------------------------------
	|	동작 시점			|				설명															|
	-------------------------------------------------------------------------------------------------
	| Before			| 비즈니스 메소드 실행 전 동작															|
	-------------------------------------------------------------------------------------------------
	| After Returning	| 비즈니스 메소드가 성공적으로 리턴되면 동작												|
	-------------------------------------------------------------------------------------------------
	| After Throwing	| 비즈니스 메소드 실행 중 예외가 발생하면 동작(try ~ catch 블록에서 catch 블록에 해당)				|
	-------------------------------------------------------------------------------------------------
	| After				| 비즈니스 메소드 실행된 후, 무조건 실행(try ~ catch ~ finally 블록에서 finally 블록에 해당)	|
	-------------------------------------------------------------------------------------------------
	| Around			| 메소드 호출 자체를 가로채 비즈니스 메소드 실행 전후에 처리할 로직을 삽입할 수 있음						|
	-------------------------------------------------------------------------------------------------
	// 참고로 예외가 발생한 상황에서도 <aop:after>가 먼저 적용된다.
	// Around 어드바이스는 클라이언트의 메소드 호출을 가로챈 후 해당 비즈니스 메소드가 실행되기 전에 사전 처리 로직을 수행할 수 있고 비즈니스 메소드 실행 후에 사후 처리 로직을 수행할 수 있다.
	// 사전 처리 로직은 Before 어드바이스와 동일하게 동작하고, 사후 처리 로직은 After 어드바이스와 동일하게 동작한다.
	public class AroundAdvice {
		public Object aroundLog(ProceedingJoinPoint pjp) throws Throwable {
			// 사전 처리 로직
			Object obj = pjp.proceed();
			// 사후 처리 로직
			return obj;
		}
	}
	
	
	
	// 횡단 관심에 해당하는 어드바이스 메소드를 의미 있게 구현하려면 클라이언트가 호출한 비즈니스 메소드의 정보가 필요하다.
	// 스프링에서는 비즈니스 메소드의 다양한 정보를 이용할 수 있도록 JoinPoint 인터페이스를 제공한다.
	// 주의할 점은 Around 어드바이스에서는 ProceedingJoinPoint를 사용해야 한다.(JoinPoint를 상속하고 proceed()를 추가했다)
	// JoinPoint에서 제공하는 메소드
	-----------------------------------------------------------------------------------------------------
	|	메소드					|				설명														|
	-----------------------------------------------------------------------------------------------------
	| Signature getSignature()	| 클라이언트가 호출한 메소드의 시그니처(리턴타입, 이름, 매개변수) 정보가 저장된 Signature 객체 리턴	|
	-----------------------------------------------------------------------------------------------------
	| Object getTarget()		| 클라이언트가 호출한 비즈니스 메소드를 포함하는 비즈니스 객체 리턴								|
	-----------------------------------------------------------------------------------------------------
	| Object[] getArgs()		| 클라이언트가 메소드를 호출할 때 넘겨준 인자 목록을 Object 배열로 리턴						|
	-----------------------------------------------------------------------------------------------------
	
	
	
	// getSignature() 메소드가 리턴하는 Signature 객체를 이용하면, 호출되는 메소드에 대한 다양한 정보를 얻을 수 있다.
	// Signature가 제공하는 메소드
	-----------------------------------------------------------------------------------------------------
	|	메소드					|				설명														|
	-----------------------------------------------------------------------------------------------------
	| String getName()			| 클라이언트가 호출한 메소드 이름 리턴												|
	-----------------------------------------------------------------------------------------------------
	| String toLongString()		| 클라이언트가 호출한 메소드의 리턴타입, 이름, 매개변수를 패키지 경로까지 포함하여 리턴				|
	-----------------------------------------------------------------------------------------------------
	| String toShortString()	| 클라이언트가 호출한 메소드 시그니처를 축약한 문자열로 리턴									|
	-----------------------------------------------------------------------------------------------------
	
	
	
	// JoinPoint 객체를 사용하려면 JoinPoint를 어드바이스 메소드 매개변수로 선언하면 된다.
	// 그러면 클라이언트가 비즈니스 메소드를 호출할 때, 스프링 컨테이너가 JoinPoint 객체를 생성한다.
	// 그리고 메소드 호출과 관련된 모든 정보를 JoinPoint 객체에 저장하여 어드바이스 메소드를 호출할 때 인자로 넘겨준다.
	ex)
	public void beforeLog(JoinPoint jp) {
		String method = jp.getSignature().getName();
		Object[] args = jp.getArgs();
		System.out.println("메소드 : " + method + "(), 메소드 인자 : " + args[0].toString());
	}
	
	
	// After Returning 어드바이스 메소드에 바인드 변수가 추가됐다면 바인드 변수에 대한 매핑 설정을 스프링 설정 파일에 추가해야 한다.
	// <aop:after-returning pointcut-ref="allPointcut" method="afterLog" returning="returnObj"/>
	public void afterLog(JoinPoint jp, Object returnObj) { // Object returnObj -> 바인드 변수
		String method = jp.getSignature().getName();
		if (returnObj instanceof UserVO) {
			...
		}
		System.out.println("메소드 : " + method + "(), 메소드 리턴값 : " + returnObj.toString());
	}
	
	
	// After Throwing 어드바이스 메소드에 바인드 변수가 추가됐다면 바인드 변수에 대한 매핑 설정을 스프링 설정 파일에 추가해야 한다.
	// <aop:after-throwing pointcut-ref="allPointcut" method="exceptionLog" throwing="exceptionObj"/>
	public void exceptionLog(JoinPoint jp, Exception exceptionObj) { // Exception exceptionObj -> 바인드 변수
		String method = jp.getSignature().getName();
		System.out.println("메소드 : " + method + "(), 메소드 수행 중 발생한 예외 메시지 : " + exceptionObj.getMessage());
	}
	
	
	
	// AOP도 IoC와 마찬가지로 어노테이션 설정을 지원한다.
	// 스프링 설정 파일에 <aop:aspectj-autoproxy> 엘리먼트만 선언하면 스프링 컨테이너는 AOP 관련 어노테이션들을 인식하고 용도에 맞게 처리해준다.
	
	// AOP 관련 어노테이션은 어드바이스 클래스에 설정한다.
	// 어노테이션 설정으로 포인트컷을 선언할 때는  @Pointcut을 사용하며 포인트컷을 식별하기 위한 참조 메소드를 이용한다.
	@Pointcut("execution( * com.springbook.biz..*Impl.*(..) )")
	public void allPointcut() {}
	
	// 어드바이스 클래스에는 횡단 관심에 해당하는 어드바이스 메소드가 있다.
	// 이 어드바이스 메소드가 언제 동작할지 결정하여 관련된 어노테이션을 메소드 위에 설정하면 된다.
	@Before("allPointcut()")
	public void printLog() {...}
	
	// 다음은 어드바이스 동작 시점과 관련된 어노테이션이다.
	// @Before,  @AfterReturning,  @AfterThrowing,  @After,  @Around
	
	// 애스팩트는 @Aspect를 이용하여 설정한다.
	// 애스팩트는 포인트컷과 어드바이스의 결합이다. 따라서 @Aspect가 설정된 애스팩트 객체에는 반드시 포인트컷과 어드바이스를 결합하는 설정이 있어야 한다.
	
	// 어드바이스 클래스마다 포인트컷 설정을 하지 않으려면 포인트컷을 외부에 독립된 클래스에 따로 설정하면 된다.
	@Aspect
	public class PointcutCommon {
		@Pointcut("execution( * com.springbook.biz..*Impl.*(..) )")
		public void allPointcut() {}
		
		@Pointcut("execution( * com.springbook.biz..*Impl.get*(..) )")
		public void getPointcut() {}
	}
	
	// 아래는 어드바이스 클래스 예시이다.
	@Service
	@Aspect
	public class BeforeAdvice {
		@Before("PointcutCommon.allPointcut()")
		public void beforeLog(JoinPoint jp) {
			String method = jp.getSignature().getName();
			Object[] args = jp.getArgs();
			System.out.println("메소드 : " + method + "(), 메소드 인자 : " + args[0].toString());
		}
	}
	
	
	@Service
	@Aspect
	public class AfterReturningAdvice {
		@AfterReturning(pointcut="PointcutCommon.allPointcut()", returning="returnObj")
		public void afterLog(JoinPoint jp, Object returnObj) { // Object returnObj -> 바인드 변수
			String method = jp.getSignature().getName();
			if (returnObj instanceof UserVO) {
				...
			}
			System.out.println("메소드 : " + method + "(), 메소드 리턴값 : " + returnObj.toString());
		}
	}
	
	
	@Service
	@Aspect
	public class AfterThrowingAdvice {
		@AfterThrowing(pointcut="PointcutCommon.allPointcut()", throwing="exceptionObj")
		public void exceptionLog(JoinPoint jp, Exception exceptionObj) { // Exception exceptionObj -> 바인드 변수
			String method = jp.getSignature().getName();
			System.out.println("메소드 : " + method + "(), 메소드 수행 중 발생한 예외 메시지 : " + exceptionObj.getMessage());
		}
	}
	
	
	@Service
	@Aspect
	public class AfterAdvice {
		@After("PointcutCommon.allPointcut()")
		public void finallyLog(JoinPoint jp) { 
			String method = jp.getSignature().getName();
			System.out.println("메소드 : " + method + "()");
		}
	}
	
	
	@Service
	@Aspect
	public class AroundAdvice {
		@Around("PointcutCommon.allPointcut()")
		public Object aroundLog(ProceedingJoinPoint pjp) throws Throwable {
			// 사전 처리 로직
			Object obj = pjp.proceed();
			// 사후 처리 로직
			return obj;
		}
	}
	
	
	
	
	

</beans>